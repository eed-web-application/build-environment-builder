// Package cbs provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen/v2 version v2.1.0 DO NOT EDIT.
package cbs

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

// Defines values for AuthorizationDTOAuthorizationType.
const (
	Admin AuthorizationDTOAuthorizationType = "Admin"
	Read  AuthorizationDTOAuthorizationType = "Read"
	Write AuthorizationDTOAuthorizationType = "Write"
)

// Defines values for AuthorizationDTOOwnerType.
const (
	Group AuthorizationDTOOwnerType = "Group"
	Token AuthorizationDTOOwnerType = "Token"
	User  AuthorizationDTOOwnerType = "User"
)

// ApiResultResponseAuthenticationTokenDTO defines model for ApiResultResponseAuthenticationTokenDTO.
type ApiResultResponseAuthenticationTokenDTO struct {
	// ErrorCode Is the error code returned from api
	ErrorCode int32 `json:"errorCode"`

	// ErrorDomain In case of error not equal to 0, an error domain can be reported by api, indicating where the problem is occurred
	ErrorDomain *string `json:"errorDomain,omitempty"`

	// ErrorMessage In case of error not equal to 0, an error message can be reported by api, indicating what problem is occurred
	ErrorMessage *string `json:"errorMessage,omitempty"`

	// Payload The authentication token
	Payload *AuthenticationTokenDTO `json:"payload,omitempty"`
}

// ApiResultResponseBoolean defines model for ApiResultResponseBoolean.
type ApiResultResponseBoolean struct {
	// ErrorCode Is the error code returned from api
	ErrorCode int32 `json:"errorCode"`

	// ErrorDomain In case of error not equal to 0, an error domain can be reported by api, indicating where the problem is occurred
	ErrorDomain *string `json:"errorDomain,omitempty"`

	// ErrorMessage In case of error not equal to 0, an error message can be reported by api, indicating what problem is occurred
	ErrorMessage *string `json:"errorMessage,omitempty"`

	// Payload Is the value returned by api
	Payload *bool `json:"payload,omitempty"`
}

// ApiResultResponseCommandTemplateDTO defines model for ApiResultResponseCommandTemplateDTO.
type ApiResultResponseCommandTemplateDTO struct {
	// ErrorCode Is the error code returned from api
	ErrorCode int32 `json:"errorCode"`

	// ErrorDomain In case of error not equal to 0, an error domain can be reported by api, indicating where the problem is occurred
	ErrorDomain *string `json:"errorDomain,omitempty"`

	// ErrorMessage In case of error not equal to 0, an error message can be reported by api, indicating what problem is occurred
	ErrorMessage *string `json:"errorMessage,omitempty"`

	// Payload Define details for create a new component
	Payload *CommandTemplateDTO `json:"payload,omitempty"`
}

// ApiResultResponseComponentDTO defines model for ApiResultResponseComponentDTO.
type ApiResultResponseComponentDTO struct {
	// ErrorCode Is the error code returned from api
	ErrorCode int32 `json:"errorCode"`

	// ErrorDomain In case of error not equal to 0, an error domain can be reported by api, indicating where the problem is occurred
	ErrorDomain *string `json:"errorDomain,omitempty"`

	// ErrorMessage In case of error not equal to 0, an error message can be reported by api, indicating what problem is occurred
	ErrorMessage *string `json:"errorMessage,omitempty"`

	// Payload Define the single component
	Payload *ComponentDTO `json:"payload,omitempty"`
}

// ApiResultResponseListAuthenticationTokenDTO defines model for ApiResultResponseListAuthenticationTokenDTO.
type ApiResultResponseListAuthenticationTokenDTO struct {
	// ErrorCode Is the error code returned from api
	ErrorCode int32 `json:"errorCode"`

	// ErrorDomain In case of error not equal to 0, an error domain can be reported by api, indicating where the problem is occurred
	ErrorDomain *string `json:"errorDomain,omitempty"`

	// ErrorMessage In case of error not equal to 0, an error message can be reported by api, indicating what problem is occurred
	ErrorMessage *string `json:"errorMessage,omitempty"`

	// Payload Is the value returned by api
	Payload *[]AuthenticationTokenDTO `json:"payload,omitempty"`
}

// ApiResultResponseListAuthorizationDTO defines model for ApiResultResponseListAuthorizationDTO.
type ApiResultResponseListAuthorizationDTO struct {
	// ErrorCode Is the error code returned from api
	ErrorCode int32 `json:"errorCode"`

	// ErrorDomain In case of error not equal to 0, an error domain can be reported by api, indicating where the problem is occurred
	ErrorDomain *string `json:"errorDomain,omitempty"`

	// ErrorMessage In case of error not equal to 0, an error message can be reported by api, indicating what problem is occurred
	ErrorMessage *string `json:"errorMessage,omitempty"`

	// Payload Is the value returned by api
	Payload *[]AuthorizationDTO `json:"payload,omitempty"`
}

// ApiResultResponseListCommandTemplateSummaryDTO defines model for ApiResultResponseListCommandTemplateSummaryDTO.
type ApiResultResponseListCommandTemplateSummaryDTO struct {
	// ErrorCode Is the error code returned from api
	ErrorCode int32 `json:"errorCode"`

	// ErrorDomain In case of error not equal to 0, an error domain can be reported by api, indicating where the problem is occurred
	ErrorDomain *string `json:"errorDomain,omitempty"`

	// ErrorMessage In case of error not equal to 0, an error message can be reported by api, indicating what problem is occurred
	ErrorMessage *string `json:"errorMessage,omitempty"`

	// Payload Is the value returned by api
	Payload *[]CommandTemplateSummaryDTO `json:"payload,omitempty"`
}

// ApiResultResponseListComponentSummaryDTO defines model for ApiResultResponseListComponentSummaryDTO.
type ApiResultResponseListComponentSummaryDTO struct {
	// ErrorCode Is the error code returned from api
	ErrorCode int32 `json:"errorCode"`

	// ErrorDomain In case of error not equal to 0, an error domain can be reported by api, indicating where the problem is occurred
	ErrorDomain *string `json:"errorDomain,omitempty"`

	// ErrorMessage In case of error not equal to 0, an error message can be reported by api, indicating what problem is occurred
	ErrorMessage *string `json:"errorMessage,omitempty"`

	// Payload Is the value returned by api
	Payload *[]ComponentSummaryDTO `json:"payload,omitempty"`
}

// ApiResultResponseListGroupDTO defines model for ApiResultResponseListGroupDTO.
type ApiResultResponseListGroupDTO struct {
	// ErrorCode Is the error code returned from api
	ErrorCode int32 `json:"errorCode"`

	// ErrorDomain In case of error not equal to 0, an error domain can be reported by api, indicating where the problem is occurred
	ErrorDomain *string `json:"errorDomain,omitempty"`

	// ErrorMessage In case of error not equal to 0, an error message can be reported by api, indicating what problem is occurred
	ErrorMessage *string `json:"errorMessage,omitempty"`

	// Payload Is the value returned by api
	Payload *[]GroupDTO `json:"payload,omitempty"`
}

// ApiResultResponseListPersonDTO defines model for ApiResultResponseListPersonDTO.
type ApiResultResponseListPersonDTO struct {
	// ErrorCode Is the error code returned from api
	ErrorCode int32 `json:"errorCode"`

	// ErrorDomain In case of error not equal to 0, an error domain can be reported by api, indicating where the problem is occurred
	ErrorDomain *string `json:"errorDomain,omitempty"`

	// ErrorMessage In case of error not equal to 0, an error message can be reported by api, indicating what problem is occurred
	ErrorMessage *string `json:"errorMessage,omitempty"`

	// Payload Is the value returned by api
	Payload *[]PersonDTO `json:"payload,omitempty"`
}

// ApiResultResponseMapStringString defines model for ApiResultResponseMapStringString.
type ApiResultResponseMapStringString struct {
	// ErrorCode Is the error code returned from api
	ErrorCode int32 `json:"errorCode"`

	// ErrorDomain In case of error not equal to 0, an error domain can be reported by api, indicating where the problem is occurred
	ErrorDomain *string `json:"errorDomain,omitempty"`

	// ErrorMessage In case of error not equal to 0, an error message can be reported by api, indicating what problem is occurred
	ErrorMessage *string `json:"errorMessage,omitempty"`

	// Payload Is the value returned by api
	Payload *map[string]string `json:"payload,omitempty"`
}

// ApiResultResponsePersonDTO defines model for ApiResultResponsePersonDTO.
type ApiResultResponsePersonDTO struct {
	// ErrorCode Is the error code returned from api
	ErrorCode int32 `json:"errorCode"`

	// ErrorDomain In case of error not equal to 0, an error domain can be reported by api, indicating where the problem is occurred
	ErrorDomain *string `json:"errorDomain,omitempty"`

	// ErrorMessage In case of error not equal to 0, an error message can be reported by api, indicating what problem is occurred
	ErrorMessage *string `json:"errorMessage,omitempty"`

	// Payload Is the value returned by api
	Payload *PersonDTO `json:"payload,omitempty"`
}

// ApiResultResponseString defines model for ApiResultResponseString.
type ApiResultResponseString struct {
	// ErrorCode Is the error code returned from api
	ErrorCode int32 `json:"errorCode"`

	// ErrorDomain In case of error not equal to 0, an error domain can be reported by api, indicating where the problem is occurred
	ErrorDomain *string `json:"errorDomain,omitempty"`

	// ErrorMessage In case of error not equal to 0, an error message can be reported by api, indicating what problem is occurred
	ErrorMessage *string `json:"errorMessage,omitempty"`

	// Payload Is the value returned by api
	Payload *string `json:"payload,omitempty"`
}

// AuthenticationTokenDTO The authentication token
type AuthenticationTokenDTO struct {
	ApplicationManaged *bool               `json:"applicationManaged,omitempty"`
	Email              *string             `json:"email,omitempty"`
	Expiration         *openapi_types.Date `json:"expiration,omitempty"`
	Id                 *string             `json:"id,omitempty"`
	Name               *string             `json:"name,omitempty"`
	Token              *string             `json:"token,omitempty"`
}

// AuthorizationDTO The authorization of the user on the resources returned in the payload
type AuthorizationDTO struct {
	// AuthorizationType Is the type of the authorizations [User, Group, Application]
	AuthorizationType *AuthorizationDTOAuthorizationType `json:"authorizationType,omitempty"`

	// Id Is unique id of the authorizations
	Id *string `json:"id,omitempty"`

	// Owner Is the subject owner of the authorizations
	Owner *string `json:"owner,omitempty"`

	// OwnerType Is the type of the owner [User, Group, Application]
	OwnerType *AuthorizationDTOOwnerType `json:"ownerType,omitempty"`

	// Resource The resource eof the authorizations
	Resource *string `json:"resource,omitempty"`
}

// AuthorizationDTOAuthorizationType Is the type of the authorizations [User, Group, Application]
type AuthorizationDTOAuthorizationType string

// AuthorizationDTOOwnerType Is the type of the owner [User, Group, Application]
type AuthorizationDTOOwnerType string

// CommandTemplateDTO Define details for create a new component
type CommandTemplateDTO struct {
	// CommandExecutionsLayers Those are the list of the action that the command will take
	CommandExecutionsLayers *[]ExecutionPipelineDTO `json:"commandExecutionsLayers,omitempty"`

	// Description The description of the component
	Description *string `json:"description,omitempty"`

	// Id The id of the component
	Id *string `json:"id,omitempty"`

	// Name The name of the component
	Name *string `json:"name,omitempty"`

	// Parameters The parameter used by the command
	Parameters *[]CommandTemplateParameterDTO `json:"parameters,omitempty"`
}

// CommandTemplateInstanceDTO Define an instance of the command template with the parameters values
type CommandTemplateInstanceDTO struct {
	// Id The id of the component
	Id *string `json:"id,omitempty"`

	// Parameters The parameter/values map
	Parameters *[]CommandTemplateInstanceParameterDTO `json:"parameters,omitempty"`
}

// CommandTemplateInstanceParameterDTO Define an instance of the command template with the parameters values
type CommandTemplateInstanceParameterDTO struct {
	// Name The name of the parameter
	Name *string `json:"name,omitempty"`

	// Value The values
	Value *string `json:"value,omitempty"`
}

// CommandTemplateParameterDTO Define a single command parameter
type CommandTemplateParameterDTO struct {
	// Description The description of the parameter
	Description string `json:"description"`

	// Name The name of the component
	Name string `json:"name"`
}

// CommandTemplateSummaryDTO Define details for create a new component
type CommandTemplateSummaryDTO struct {
	// CommandExecutionsLayers Those are the list of the action that the command will take
	CommandExecutionsLayers *[]ExecutionPipelineDTO `json:"commandExecutionsLayers,omitempty"`

	// Id The id of the component
	Id *string `json:"id,omitempty"`

	// Name The name of the component
	Name *string `json:"name,omitempty"`

	// Parameters The parameter used by the command
	Parameters *[]CommandTemplateParameterDTO `json:"parameters,omitempty"`
}

// ComponentDTO Define the single component
type ComponentDTO struct {
	// CommandTemplatesInstances The list command template instances to execute to build the component.
	CommandTemplatesInstances *[]CommandTemplateInstanceDTO `json:"commandTemplatesInstances,omitempty"`

	// DependOnComponentIds The list of unique identifier of the components that this component depends on.
	DependOnComponentIds *[]string `json:"dependOnComponentIds,omitempty"`

	// Description The description of the component
	Description *string `json:"description,omitempty"`

	// Id The unique identifier of the component
	Id *string `json:"id,omitempty"`

	// Name The name of the component
	Name *string `json:"name,omitempty"`

	// Url The URL of the component [src, artifact, etc.]
	Url *string `json:"url,omitempty"`
}

// ComponentSummaryDTO Define the single component
type ComponentSummaryDTO struct {
	// Description The description of the component
	Description *string `json:"description,omitempty"`

	// Id The unique identifier of the component
	Id *string `json:"id,omitempty"`

	// Name The name of the component
	Name *string `json:"name,omitempty"`
}

// ExecutionPipelineDTO Define details for create a new execution pipeline for a command
type ExecutionPipelineDTO struct {
	// Architecture The architecture where the pipeline can work
	Architecture *[]string `json:"architecture,omitempty"`

	// Engine The name of the pipeline
	Engine *string `json:"engine,omitempty"`

	// ExecutionCommands The list of the commands that the pipeline will execute
	ExecutionCommands *[]string `json:"executionCommands,omitempty"`

	// OperatingSystem The operating system where the pipeline can work
	OperatingSystem *[]string `json:"operatingSystem,omitempty"`
}

// GroupDTO The group of the user
type GroupDTO struct {
	CommonName *string `json:"commonName,omitempty"`
	Uid        *string `json:"uid,omitempty"`
}

// NewAuthenticationTokenDTO New authentication token for logbook
type NewAuthenticationTokenDTO struct {
	Expiration *openapi_types.Date `json:"expiration,omitempty"`
	Name       *string             `json:"name,omitempty"`
}

// NewCommandTemplateDTO Define details for create a new component
type NewCommandTemplateDTO struct {
	// CommandExecutionsLayers Those are the list of the action that the command will take
	CommandExecutionsLayers []ExecutionPipelineDTO `json:"commandExecutionsLayers"`

	// Description The description of the component
	Description string `json:"description"`

	// Name The name of the component
	Name string `json:"name"`

	// Parameters The parameter used by the command
	Parameters []CommandTemplateParameterDTO `json:"parameters"`
}

// NewComponentDTO Define details for create a new component
type NewComponentDTO struct {
	// CommandTemplates The list of command templates that the component will use.
	CommandTemplates *[]CommandTemplateDTO `json:"commandTemplates,omitempty"`

	// CommandTemplatesInstances The list command template instances to execute to build the component.
	CommandTemplatesInstances []CommandTemplateInstanceDTO `json:"commandTemplatesInstances"`

	// DependOnComponentIds The list of unique identifier of the components that this component depends on.
	DependOnComponentIds *[]string `json:"dependOnComponentIds,omitempty"`

	// Description The description of the component
	Description *string `json:"description,omitempty"`

	// Name The name of the component
	Name string `json:"name"`

	// Version The version of the component
	Version string `json:"version"`
}

// PersonDTO Is the value returned by api
type PersonDTO struct {
	CommonName *string `json:"commonName,omitempty"`
	Gecos      *string `json:"gecos,omitempty"`
	Mail       *string `json:"mail,omitempty"`
	Surname    *string `json:"surname,omitempty"`
	Uid        *string `json:"uid,omitempty"`
}

// UpdateCommandTemplateDTO Define details for create a new component
type UpdateCommandTemplateDTO struct {
	// CommandExecutionsLayers Those are the list of the action that the command will take
	CommandExecutionsLayers *[]ExecutionPipelineDTO `json:"commandExecutionsLayers,omitempty"`

	// Description The description of the component
	Description *string `json:"description,omitempty"`

	// Name The name of the component
	Name *string `json:"name,omitempty"`

	// Parameters The parameter used by the command
	Parameters *[]CommandTemplateParameterDTO `json:"parameters,omitempty"`
}

// UpdateComponentDTO Define the single component
type UpdateComponentDTO struct {
	// CommandTemplatesInstances The list command template instances to execute to build the component.
	CommandTemplatesInstances *[]CommandTemplateInstanceDTO `json:"commandTemplatesInstances,omitempty"`

	// DependOnComponentIds The list of unique identifier of the components that this component depends on.
	DependOnComponentIds *[]string `json:"dependOnComponentIds,omitempty"`

	// Description The description of the component
	Description *string `json:"description,omitempty"`

	// Name The name of the component
	Name *string `json:"name,omitempty"`

	// Url The URL of the component [src, artifact, etc.]
	Url *string `json:"url,omitempty"`
}

// FindGroupsParams defines parameters for FindGroups.
type FindGroupsParams struct {
	// Search is the prefix used to filter the groups
	Search *string `form:"search,omitempty" json:"search,omitempty"`
}

// FindPeopleParams defines parameters for FindPeople.
type FindPeopleParams struct {
	// Search is the prefix used to filter the people
	Search *string `form:"search,omitempty" json:"search,omitempty"`
}

// CreateNewAuthenticationTokenJSONRequestBody defines body for CreateNewAuthenticationToken for application/json ContentType.
type CreateNewAuthenticationTokenJSONRequestBody = NewAuthenticationTokenDTO

// CreateCommandJSONRequestBody defines body for CreateCommand for application/json ContentType.
type CreateCommandJSONRequestBody = NewCommandTemplateDTO

// UpdateCommandByIdJSONRequestBody defines body for UpdateCommandById for application/json ContentType.
type UpdateCommandByIdJSONRequestBody = UpdateCommandTemplateDTO

// CreateJSONRequestBody defines body for Create for application/json ContentType.
type CreateJSONRequestBody = NewComponentDTO

// UpdateByIdJSONRequestBody defines body for UpdateById for application/json ContentType.
type UpdateByIdJSONRequestBody = UpdateComponentDTO

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// GetApplicationAuthenticationToken request
	GetApplicationAuthenticationToken(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateNewAuthenticationTokenWithBody request with any body
	CreateNewAuthenticationTokenWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateNewAuthenticationToken(ctx context.Context, body CreateNewAuthenticationTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteAuthenticationToken request
	DeleteAuthenticationToken(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindGroups request
	FindGroups(ctx context.Context, params *FindGroupsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Me request
	Me(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindAllRoot request
	FindAllRoot(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveAsRootUser request
	RemoveAsRootUser(ctx context.Context, email string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetRootUser request
	SetRootUser(ctx context.Context, email string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindPeople request
	FindPeople(ctx context.Context, params *FindPeopleParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListAllCommand request
	ListAllCommand(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateCommandWithBody request with any body
	CreateCommandWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateCommand(ctx context.Context, body CreateCommandJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteCommandById request
	DeleteCommandById(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindCommandById request
	FindCommandById(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateCommandByIdWithBody request with any body
	UpdateCommandByIdWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateCommandById(ctx context.Context, id string, body UpdateCommandByIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListAllComponent request
	ListAllComponent(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateWithBody request with any body
	CreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	Create(ctx context.Context, body CreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteById request
	DeleteById(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindById request
	FindById(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateByIdWithBody request with any body
	UpdateByIdWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateById(ctx context.Context, id string, body UpdateByIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteAll request
	DeleteAll(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Echo request
	Echo(ctx context.Context, value string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMockUser request
	GetMockUser(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) GetApplicationAuthenticationToken(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetApplicationAuthenticationTokenRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateNewAuthenticationTokenWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateNewAuthenticationTokenRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateNewAuthenticationToken(ctx context.Context, body CreateNewAuthenticationTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateNewAuthenticationTokenRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteAuthenticationToken(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteAuthenticationTokenRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindGroups(ctx context.Context, params *FindGroupsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindGroupsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Me(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMeRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindAllRoot(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindAllRootRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveAsRootUser(ctx context.Context, email string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveAsRootUserRequest(c.Server, email)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetRootUser(ctx context.Context, email string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetRootUserRequest(c.Server, email)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindPeople(ctx context.Context, params *FindPeopleParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindPeopleRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListAllCommand(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListAllCommandRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateCommandWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateCommandRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateCommand(ctx context.Context, body CreateCommandJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateCommandRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteCommandById(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteCommandByIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindCommandById(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindCommandByIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateCommandByIdWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateCommandByIdRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateCommandById(ctx context.Context, id string, body UpdateCommandByIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateCommandByIdRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListAllComponent(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListAllComponentRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Create(ctx context.Context, body CreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteById(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteByIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindById(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindByIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateByIdWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateByIdRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateById(ctx context.Context, id string, body UpdateByIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateByIdRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteAll(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteAllRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Echo(ctx context.Context, value string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEchoRequest(c.Server, value)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMockUser(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMockUserRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewGetApplicationAuthenticationTokenRequest generates requests for GetApplicationAuthenticationToken
func NewGetApplicationAuthenticationTokenRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/auth/application-token")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateNewAuthenticationTokenRequest calls the generic CreateNewAuthenticationToken builder with application/json body
func NewCreateNewAuthenticationTokenRequest(server string, body CreateNewAuthenticationTokenJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateNewAuthenticationTokenRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateNewAuthenticationTokenRequestWithBody generates requests for CreateNewAuthenticationToken with any type of body
func NewCreateNewAuthenticationTokenRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/auth/application-token")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteAuthenticationTokenRequest generates requests for DeleteAuthenticationToken
func NewDeleteAuthenticationTokenRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/auth/application-token/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindGroupsRequest generates requests for FindGroups
func NewFindGroupsRequest(server string, params *FindGroupsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/auth/groups")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Search != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "search", runtime.ParamLocationQuery, *params.Search); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewMeRequest generates requests for Me
func NewMeRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/auth/me")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindAllRootRequest generates requests for FindAllRoot
func NewFindAllRootRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/auth/root")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRemoveAsRootUserRequest generates requests for RemoveAsRootUser
func NewRemoveAsRootUserRequest(server string, email string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "email", runtime.ParamLocationPath, email)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/auth/root/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetRootUserRequest generates requests for SetRootUser
func NewSetRootUserRequest(server string, email string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "email", runtime.ParamLocationPath, email)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/auth/root/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindPeopleRequest generates requests for FindPeople
func NewFindPeopleRequest(server string, params *FindPeopleParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/auth/users")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Search != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "search", runtime.ParamLocationQuery, *params.Search); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListAllCommandRequest generates requests for ListAllCommand
func NewListAllCommandRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/command")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateCommandRequest calls the generic CreateCommand builder with application/json body
func NewCreateCommandRequest(server string, body CreateCommandJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateCommandRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateCommandRequestWithBody generates requests for CreateCommand with any type of body
func NewCreateCommandRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/command")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteCommandByIdRequest generates requests for DeleteCommandById
func NewDeleteCommandByIdRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/command/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindCommandByIdRequest generates requests for FindCommandById
func NewFindCommandByIdRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/command/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateCommandByIdRequest calls the generic UpdateCommandById builder with application/json body
func NewUpdateCommandByIdRequest(server string, id string, body UpdateCommandByIdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateCommandByIdRequestWithBody(server, id, "application/json", bodyReader)
}

// NewUpdateCommandByIdRequestWithBody generates requests for UpdateCommandById with any type of body
func NewUpdateCommandByIdRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/command/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListAllComponentRequest generates requests for ListAllComponent
func NewListAllComponentRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/component")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateRequest calls the generic Create builder with application/json body
func NewCreateRequest(server string, body CreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateRequestWithBody generates requests for Create with any type of body
func NewCreateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/component")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteByIdRequest generates requests for DeleteById
func NewDeleteByIdRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/component/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindByIdRequest generates requests for FindById
func NewFindByIdRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/component/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateByIdRequest calls the generic UpdateById builder with application/json body
func NewUpdateByIdRequest(server string, id string, body UpdateByIdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateByIdRequestWithBody(server, id, "application/json", bodyReader)
}

// NewUpdateByIdRequestWithBody generates requests for UpdateById with any type of body
func NewUpdateByIdRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/component/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteAllRequest generates requests for DeleteAll
func NewDeleteAllRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/debug")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewEchoRequest generates requests for Echo
func NewEchoRequest(server string, value string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "value", runtime.ParamLocationPath, value)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/echo/test/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetMockUserRequest generates requests for GetMockUser
func NewGetMockUserRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/mock/users-auth")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// GetApplicationAuthenticationTokenWithResponse request
	GetApplicationAuthenticationTokenWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetApplicationAuthenticationTokenResponse, error)

	// CreateNewAuthenticationTokenWithBodyWithResponse request with any body
	CreateNewAuthenticationTokenWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateNewAuthenticationTokenResponse, error)

	CreateNewAuthenticationTokenWithResponse(ctx context.Context, body CreateNewAuthenticationTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateNewAuthenticationTokenResponse, error)

	// DeleteAuthenticationTokenWithResponse request
	DeleteAuthenticationTokenWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteAuthenticationTokenResponse, error)

	// FindGroupsWithResponse request
	FindGroupsWithResponse(ctx context.Context, params *FindGroupsParams, reqEditors ...RequestEditorFn) (*FindGroupsResponse, error)

	// MeWithResponse request
	MeWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*MeResponse, error)

	// FindAllRootWithResponse request
	FindAllRootWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*FindAllRootResponse, error)

	// RemoveAsRootUserWithResponse request
	RemoveAsRootUserWithResponse(ctx context.Context, email string, reqEditors ...RequestEditorFn) (*RemoveAsRootUserResponse, error)

	// SetRootUserWithResponse request
	SetRootUserWithResponse(ctx context.Context, email string, reqEditors ...RequestEditorFn) (*SetRootUserResponse, error)

	// FindPeopleWithResponse request
	FindPeopleWithResponse(ctx context.Context, params *FindPeopleParams, reqEditors ...RequestEditorFn) (*FindPeopleResponse, error)

	// ListAllCommandWithResponse request
	ListAllCommandWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListAllCommandResponse, error)

	// CreateCommandWithBodyWithResponse request with any body
	CreateCommandWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateCommandResponse, error)

	CreateCommandWithResponse(ctx context.Context, body CreateCommandJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateCommandResponse, error)

	// DeleteCommandByIdWithResponse request
	DeleteCommandByIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteCommandByIdResponse, error)

	// FindCommandByIdWithResponse request
	FindCommandByIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*FindCommandByIdResponse, error)

	// UpdateCommandByIdWithBodyWithResponse request with any body
	UpdateCommandByIdWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateCommandByIdResponse, error)

	UpdateCommandByIdWithResponse(ctx context.Context, id string, body UpdateCommandByIdJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateCommandByIdResponse, error)

	// ListAllComponentWithResponse request
	ListAllComponentWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListAllComponentResponse, error)

	// CreateWithBodyWithResponse request with any body
	CreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateResponse, error)

	CreateWithResponse(ctx context.Context, body CreateJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateResponse, error)

	// DeleteByIdWithResponse request
	DeleteByIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteByIdResponse, error)

	// FindByIdWithResponse request
	FindByIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*FindByIdResponse, error)

	// UpdateByIdWithBodyWithResponse request with any body
	UpdateByIdWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateByIdResponse, error)

	UpdateByIdWithResponse(ctx context.Context, id string, body UpdateByIdJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateByIdResponse, error)

	// DeleteAllWithResponse request
	DeleteAllWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*DeleteAllResponse, error)

	// EchoWithResponse request
	EchoWithResponse(ctx context.Context, value string, reqEditors ...RequestEditorFn) (*EchoResponse, error)

	// GetMockUserWithResponse request
	GetMockUserWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetMockUserResponse, error)
}

type GetApplicationAuthenticationTokenResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ApiResultResponseListAuthenticationTokenDTO
}

// Status returns HTTPResponse.Status
func (r GetApplicationAuthenticationTokenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetApplicationAuthenticationTokenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateNewAuthenticationTokenResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *ApiResultResponseAuthenticationTokenDTO
}

// Status returns HTTPResponse.Status
func (r CreateNewAuthenticationTokenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateNewAuthenticationTokenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteAuthenticationTokenResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ApiResultResponseBoolean
}

// Status returns HTTPResponse.Status
func (r DeleteAuthenticationTokenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteAuthenticationTokenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindGroupsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ApiResultResponseListGroupDTO
}

// Status returns HTTPResponse.Status
func (r FindGroupsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindGroupsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ApiResultResponsePersonDTO
}

// Status returns HTTPResponse.Status
func (r MeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindAllRootResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ApiResultResponseListAuthorizationDTO
}

// Status returns HTTPResponse.Status
func (r FindAllRootResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindAllRootResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveAsRootUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ApiResultResponseBoolean
}

// Status returns HTTPResponse.Status
func (r RemoveAsRootUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveAsRootUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetRootUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *ApiResultResponseBoolean
}

// Status returns HTTPResponse.Status
func (r SetRootUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetRootUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindPeopleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ApiResultResponseListPersonDTO
}

// Status returns HTTPResponse.Status
func (r FindPeopleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindPeopleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListAllCommandResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ApiResultResponseListCommandTemplateSummaryDTO
}

// Status returns HTTPResponse.Status
func (r ListAllCommandResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListAllCommandResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateCommandResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *ApiResultResponseString
}

// Status returns HTTPResponse.Status
func (r CreateCommandResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateCommandResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteCommandByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ApiResultResponseBoolean
}

// Status returns HTTPResponse.Status
func (r DeleteCommandByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteCommandByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindCommandByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ApiResultResponseCommandTemplateDTO
}

// Status returns HTTPResponse.Status
func (r FindCommandByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindCommandByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateCommandByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ApiResultResponseBoolean
}

// Status returns HTTPResponse.Status
func (r UpdateCommandByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateCommandByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListAllComponentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ApiResultResponseListComponentSummaryDTO
}

// Status returns HTTPResponse.Status
func (r ListAllComponentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListAllComponentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *ApiResultResponseString
}

// Status returns HTTPResponse.Status
func (r CreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ApiResultResponseBoolean
}

// Status returns HTTPResponse.Status
func (r DeleteByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ApiResultResponseComponentDTO
}

// Status returns HTTPResponse.Status
func (r FindByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ApiResultResponseBoolean
}

// Status returns HTTPResponse.Status
func (r UpdateByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteAllResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *ApiResultResponseBoolean
}

// Status returns HTTPResponse.Status
func (r DeleteAllResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteAllResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EchoResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ApiResultResponseString
}

// Status returns HTTPResponse.Status
func (r EchoResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EchoResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMockUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ApiResultResponseMapStringString
}

// Status returns HTTPResponse.Status
func (r GetMockUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMockUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetApplicationAuthenticationTokenWithResponse request returning *GetApplicationAuthenticationTokenResponse
func (c *ClientWithResponses) GetApplicationAuthenticationTokenWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetApplicationAuthenticationTokenResponse, error) {
	rsp, err := c.GetApplicationAuthenticationToken(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetApplicationAuthenticationTokenResponse(rsp)
}

// CreateNewAuthenticationTokenWithBodyWithResponse request with arbitrary body returning *CreateNewAuthenticationTokenResponse
func (c *ClientWithResponses) CreateNewAuthenticationTokenWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateNewAuthenticationTokenResponse, error) {
	rsp, err := c.CreateNewAuthenticationTokenWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateNewAuthenticationTokenResponse(rsp)
}

func (c *ClientWithResponses) CreateNewAuthenticationTokenWithResponse(ctx context.Context, body CreateNewAuthenticationTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateNewAuthenticationTokenResponse, error) {
	rsp, err := c.CreateNewAuthenticationToken(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateNewAuthenticationTokenResponse(rsp)
}

// DeleteAuthenticationTokenWithResponse request returning *DeleteAuthenticationTokenResponse
func (c *ClientWithResponses) DeleteAuthenticationTokenWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteAuthenticationTokenResponse, error) {
	rsp, err := c.DeleteAuthenticationToken(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteAuthenticationTokenResponse(rsp)
}

// FindGroupsWithResponse request returning *FindGroupsResponse
func (c *ClientWithResponses) FindGroupsWithResponse(ctx context.Context, params *FindGroupsParams, reqEditors ...RequestEditorFn) (*FindGroupsResponse, error) {
	rsp, err := c.FindGroups(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindGroupsResponse(rsp)
}

// MeWithResponse request returning *MeResponse
func (c *ClientWithResponses) MeWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*MeResponse, error) {
	rsp, err := c.Me(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMeResponse(rsp)
}

// FindAllRootWithResponse request returning *FindAllRootResponse
func (c *ClientWithResponses) FindAllRootWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*FindAllRootResponse, error) {
	rsp, err := c.FindAllRoot(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindAllRootResponse(rsp)
}

// RemoveAsRootUserWithResponse request returning *RemoveAsRootUserResponse
func (c *ClientWithResponses) RemoveAsRootUserWithResponse(ctx context.Context, email string, reqEditors ...RequestEditorFn) (*RemoveAsRootUserResponse, error) {
	rsp, err := c.RemoveAsRootUser(ctx, email, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveAsRootUserResponse(rsp)
}

// SetRootUserWithResponse request returning *SetRootUserResponse
func (c *ClientWithResponses) SetRootUserWithResponse(ctx context.Context, email string, reqEditors ...RequestEditorFn) (*SetRootUserResponse, error) {
	rsp, err := c.SetRootUser(ctx, email, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetRootUserResponse(rsp)
}

// FindPeopleWithResponse request returning *FindPeopleResponse
func (c *ClientWithResponses) FindPeopleWithResponse(ctx context.Context, params *FindPeopleParams, reqEditors ...RequestEditorFn) (*FindPeopleResponse, error) {
	rsp, err := c.FindPeople(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindPeopleResponse(rsp)
}

// ListAllCommandWithResponse request returning *ListAllCommandResponse
func (c *ClientWithResponses) ListAllCommandWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListAllCommandResponse, error) {
	rsp, err := c.ListAllCommand(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListAllCommandResponse(rsp)
}

// CreateCommandWithBodyWithResponse request with arbitrary body returning *CreateCommandResponse
func (c *ClientWithResponses) CreateCommandWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateCommandResponse, error) {
	rsp, err := c.CreateCommandWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateCommandResponse(rsp)
}

func (c *ClientWithResponses) CreateCommandWithResponse(ctx context.Context, body CreateCommandJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateCommandResponse, error) {
	rsp, err := c.CreateCommand(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateCommandResponse(rsp)
}

// DeleteCommandByIdWithResponse request returning *DeleteCommandByIdResponse
func (c *ClientWithResponses) DeleteCommandByIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteCommandByIdResponse, error) {
	rsp, err := c.DeleteCommandById(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteCommandByIdResponse(rsp)
}

// FindCommandByIdWithResponse request returning *FindCommandByIdResponse
func (c *ClientWithResponses) FindCommandByIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*FindCommandByIdResponse, error) {
	rsp, err := c.FindCommandById(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindCommandByIdResponse(rsp)
}

// UpdateCommandByIdWithBodyWithResponse request with arbitrary body returning *UpdateCommandByIdResponse
func (c *ClientWithResponses) UpdateCommandByIdWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateCommandByIdResponse, error) {
	rsp, err := c.UpdateCommandByIdWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateCommandByIdResponse(rsp)
}

func (c *ClientWithResponses) UpdateCommandByIdWithResponse(ctx context.Context, id string, body UpdateCommandByIdJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateCommandByIdResponse, error) {
	rsp, err := c.UpdateCommandById(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateCommandByIdResponse(rsp)
}

// ListAllComponentWithResponse request returning *ListAllComponentResponse
func (c *ClientWithResponses) ListAllComponentWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListAllComponentResponse, error) {
	rsp, err := c.ListAllComponent(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListAllComponentResponse(rsp)
}

// CreateWithBodyWithResponse request with arbitrary body returning *CreateResponse
func (c *ClientWithResponses) CreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateResponse, error) {
	rsp, err := c.CreateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateResponse(rsp)
}

func (c *ClientWithResponses) CreateWithResponse(ctx context.Context, body CreateJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateResponse, error) {
	rsp, err := c.Create(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateResponse(rsp)
}

// DeleteByIdWithResponse request returning *DeleteByIdResponse
func (c *ClientWithResponses) DeleteByIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteByIdResponse, error) {
	rsp, err := c.DeleteById(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteByIdResponse(rsp)
}

// FindByIdWithResponse request returning *FindByIdResponse
func (c *ClientWithResponses) FindByIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*FindByIdResponse, error) {
	rsp, err := c.FindById(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindByIdResponse(rsp)
}

// UpdateByIdWithBodyWithResponse request with arbitrary body returning *UpdateByIdResponse
func (c *ClientWithResponses) UpdateByIdWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateByIdResponse, error) {
	rsp, err := c.UpdateByIdWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateByIdResponse(rsp)
}

func (c *ClientWithResponses) UpdateByIdWithResponse(ctx context.Context, id string, body UpdateByIdJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateByIdResponse, error) {
	rsp, err := c.UpdateById(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateByIdResponse(rsp)
}

// DeleteAllWithResponse request returning *DeleteAllResponse
func (c *ClientWithResponses) DeleteAllWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*DeleteAllResponse, error) {
	rsp, err := c.DeleteAll(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteAllResponse(rsp)
}

// EchoWithResponse request returning *EchoResponse
func (c *ClientWithResponses) EchoWithResponse(ctx context.Context, value string, reqEditors ...RequestEditorFn) (*EchoResponse, error) {
	rsp, err := c.Echo(ctx, value, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEchoResponse(rsp)
}

// GetMockUserWithResponse request returning *GetMockUserResponse
func (c *ClientWithResponses) GetMockUserWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetMockUserResponse, error) {
	rsp, err := c.GetMockUser(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMockUserResponse(rsp)
}

// ParseGetApplicationAuthenticationTokenResponse parses an HTTP response from a GetApplicationAuthenticationTokenWithResponse call
func ParseGetApplicationAuthenticationTokenResponse(rsp *http.Response) (*GetApplicationAuthenticationTokenResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetApplicationAuthenticationTokenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ApiResultResponseListAuthenticationTokenDTO
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateNewAuthenticationTokenResponse parses an HTTP response from a CreateNewAuthenticationTokenWithResponse call
func ParseCreateNewAuthenticationTokenResponse(rsp *http.Response) (*CreateNewAuthenticationTokenResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateNewAuthenticationTokenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest ApiResultResponseAuthenticationTokenDTO
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseDeleteAuthenticationTokenResponse parses an HTTP response from a DeleteAuthenticationTokenWithResponse call
func ParseDeleteAuthenticationTokenResponse(rsp *http.Response) (*DeleteAuthenticationTokenResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteAuthenticationTokenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ApiResultResponseBoolean
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseFindGroupsResponse parses an HTTP response from a FindGroupsWithResponse call
func ParseFindGroupsResponse(rsp *http.Response) (*FindGroupsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindGroupsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ApiResultResponseListGroupDTO
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseMeResponse parses an HTTP response from a MeWithResponse call
func ParseMeResponse(rsp *http.Response) (*MeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ApiResultResponsePersonDTO
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseFindAllRootResponse parses an HTTP response from a FindAllRootWithResponse call
func ParseFindAllRootResponse(rsp *http.Response) (*FindAllRootResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindAllRootResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ApiResultResponseListAuthorizationDTO
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseRemoveAsRootUserResponse parses an HTTP response from a RemoveAsRootUserWithResponse call
func ParseRemoveAsRootUserResponse(rsp *http.Response) (*RemoveAsRootUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemoveAsRootUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ApiResultResponseBoolean
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseSetRootUserResponse parses an HTTP response from a SetRootUserWithResponse call
func ParseSetRootUserResponse(rsp *http.Response) (*SetRootUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetRootUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest ApiResultResponseBoolean
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseFindPeopleResponse parses an HTTP response from a FindPeopleWithResponse call
func ParseFindPeopleResponse(rsp *http.Response) (*FindPeopleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindPeopleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ApiResultResponseListPersonDTO
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListAllCommandResponse parses an HTTP response from a ListAllCommandWithResponse call
func ParseListAllCommandResponse(rsp *http.Response) (*ListAllCommandResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListAllCommandResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ApiResultResponseListCommandTemplateSummaryDTO
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateCommandResponse parses an HTTP response from a CreateCommandWithResponse call
func ParseCreateCommandResponse(rsp *http.Response) (*CreateCommandResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateCommandResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest ApiResultResponseString
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseDeleteCommandByIdResponse parses an HTTP response from a DeleteCommandByIdWithResponse call
func ParseDeleteCommandByIdResponse(rsp *http.Response) (*DeleteCommandByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteCommandByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ApiResultResponseBoolean
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseFindCommandByIdResponse parses an HTTP response from a FindCommandByIdWithResponse call
func ParseFindCommandByIdResponse(rsp *http.Response) (*FindCommandByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindCommandByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ApiResultResponseCommandTemplateDTO
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateCommandByIdResponse parses an HTTP response from a UpdateCommandByIdWithResponse call
func ParseUpdateCommandByIdResponse(rsp *http.Response) (*UpdateCommandByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateCommandByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ApiResultResponseBoolean
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListAllComponentResponse parses an HTTP response from a ListAllComponentWithResponse call
func ParseListAllComponentResponse(rsp *http.Response) (*ListAllComponentResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListAllComponentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ApiResultResponseListComponentSummaryDTO
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateResponse parses an HTTP response from a CreateWithResponse call
func ParseCreateResponse(rsp *http.Response) (*CreateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest ApiResultResponseString
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseDeleteByIdResponse parses an HTTP response from a DeleteByIdWithResponse call
func ParseDeleteByIdResponse(rsp *http.Response) (*DeleteByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ApiResultResponseBoolean
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseFindByIdResponse parses an HTTP response from a FindByIdWithResponse call
func ParseFindByIdResponse(rsp *http.Response) (*FindByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ApiResultResponseComponentDTO
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateByIdResponse parses an HTTP response from a UpdateByIdWithResponse call
func ParseUpdateByIdResponse(rsp *http.Response) (*UpdateByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ApiResultResponseBoolean
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteAllResponse parses an HTTP response from a DeleteAllWithResponse call
func ParseDeleteAllResponse(rsp *http.Response) (*DeleteAllResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteAllResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest ApiResultResponseBoolean
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseEchoResponse parses an HTTP response from a EchoWithResponse call
func ParseEchoResponse(rsp *http.Response) (*EchoResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EchoResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ApiResultResponseString
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetMockUserResponse parses an HTTP response from a GetMockUserWithResponse call
func ParseGetMockUserResponse(rsp *http.Response) (*GetMockUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMockUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ApiResultResponseMapStringString
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ServerInterface represents all server handlers.
type ServerInterface interface {

	// (GET /v1/auth/application-token)
	GetApplicationAuthenticationToken(ctx echo.Context) error

	// (POST /v1/auth/application-token)
	CreateNewAuthenticationToken(ctx echo.Context) error

	// (DELETE /v1/auth/application-token/{id})
	DeleteAuthenticationToken(ctx echo.Context, id string) error

	// (GET /v1/auth/groups)
	FindGroups(ctx echo.Context, params FindGroupsParams) error

	// (GET /v1/auth/me)
	Me(ctx echo.Context) error

	// (GET /v1/auth/root)
	FindAllRoot(ctx echo.Context) error

	// (DELETE /v1/auth/root/{email})
	RemoveAsRootUser(ctx echo.Context, email string) error

	// (POST /v1/auth/root/{email})
	SetRootUser(ctx echo.Context, email string) error

	// (GET /v1/auth/users)
	FindPeople(ctx echo.Context, params FindPeopleParams) error
	// List all command templates
	// (GET /v1/command)
	ListAllCommand(ctx echo.Context) error
	// Create a new component
	// (POST /v1/command)
	CreateCommand(ctx echo.Context) error
	// Return a command template by its unique identifier
	// (DELETE /v1/command/{id})
	DeleteCommandById(ctx echo.Context, id string) error
	// List all command templates
	// (GET /v1/command/{id})
	FindCommandById(ctx echo.Context, id string) error
	// Update a command template by its unique identifier
	// (PUT /v1/command/{id})
	UpdateCommandById(ctx echo.Context, id string) error
	// List all components
	// (GET /v1/component)
	ListAllComponent(ctx echo.Context) error
	// Create a new component
	// (POST /v1/component)
	Create(ctx echo.Context) error
	// Delete a component by his id
	// (DELETE /v1/component/{id})
	DeleteById(ctx echo.Context, id string) error
	// Find a component by an id
	// (GET /v1/component/{id})
	FindById(ctx echo.Context, id string) error
	// Delete a component by his id
	// (PUT /v1/component/{id})
	UpdateById(ctx echo.Context, id string) error
	// Reset all the data
	// (POST /v1/debug)
	DeleteAll(ctx echo.Context) error
	// Example api that realize an ECHO
	// (GET /v1/echo/test/{value})
	Echo(ctx echo.Context, value string) error

	// (GET /v1/mock/users-auth)
	GetMockUser(ctx echo.Context) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// GetApplicationAuthenticationToken converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationAuthenticationToken(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetApplicationAuthenticationToken(ctx)
	return err
}

// CreateNewAuthenticationToken converts echo context to params.
func (w *ServerInterfaceWrapper) CreateNewAuthenticationToken(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.CreateNewAuthenticationToken(ctx)
	return err
}

// DeleteAuthenticationToken converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteAuthenticationToken(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteAuthenticationToken(ctx, id)
	return err
}

// FindGroups converts echo context to params.
func (w *ServerInterfaceWrapper) FindGroups(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params FindGroupsParams
	// ------------- Optional query parameter "search" -------------

	err = runtime.BindQueryParameter("form", true, false, "search", ctx.QueryParams(), &params.Search)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter search: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.FindGroups(ctx, params)
	return err
}

// Me converts echo context to params.
func (w *ServerInterfaceWrapper) Me(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.Me(ctx)
	return err
}

// FindAllRoot converts echo context to params.
func (w *ServerInterfaceWrapper) FindAllRoot(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.FindAllRoot(ctx)
	return err
}

// RemoveAsRootUser converts echo context to params.
func (w *ServerInterfaceWrapper) RemoveAsRootUser(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "email" -------------
	var email string

	err = runtime.BindStyledParameterWithOptions("simple", "email", ctx.Param("email"), &email, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter email: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.RemoveAsRootUser(ctx, email)
	return err
}

// SetRootUser converts echo context to params.
func (w *ServerInterfaceWrapper) SetRootUser(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "email" -------------
	var email string

	err = runtime.BindStyledParameterWithOptions("simple", "email", ctx.Param("email"), &email, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter email: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.SetRootUser(ctx, email)
	return err
}

// FindPeople converts echo context to params.
func (w *ServerInterfaceWrapper) FindPeople(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params FindPeopleParams
	// ------------- Optional query parameter "search" -------------

	err = runtime.BindQueryParameter("form", true, false, "search", ctx.QueryParams(), &params.Search)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter search: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.FindPeople(ctx, params)
	return err
}

// ListAllCommand converts echo context to params.
func (w *ServerInterfaceWrapper) ListAllCommand(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ListAllCommand(ctx)
	return err
}

// CreateCommand converts echo context to params.
func (w *ServerInterfaceWrapper) CreateCommand(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.CreateCommand(ctx)
	return err
}

// DeleteCommandById converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteCommandById(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteCommandById(ctx, id)
	return err
}

// FindCommandById converts echo context to params.
func (w *ServerInterfaceWrapper) FindCommandById(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.FindCommandById(ctx, id)
	return err
}

// UpdateCommandById converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateCommandById(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.UpdateCommandById(ctx, id)
	return err
}

// ListAllComponent converts echo context to params.
func (w *ServerInterfaceWrapper) ListAllComponent(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ListAllComponent(ctx)
	return err
}

// Create converts echo context to params.
func (w *ServerInterfaceWrapper) Create(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.Create(ctx)
	return err
}

// DeleteById converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteById(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteById(ctx, id)
	return err
}

// FindById converts echo context to params.
func (w *ServerInterfaceWrapper) FindById(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.FindById(ctx, id)
	return err
}

// UpdateById converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateById(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.UpdateById(ctx, id)
	return err
}

// DeleteAll converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteAll(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteAll(ctx)
	return err
}

// Echo converts echo context to params.
func (w *ServerInterfaceWrapper) Echo(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "value" -------------
	var value string

	err = runtime.BindStyledParameterWithOptions("simple", "value", ctx.Param("value"), &value, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter value: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.Echo(ctx, value)
	return err
}

// GetMockUser converts echo context to params.
func (w *ServerInterfaceWrapper) GetMockUser(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetMockUser(ctx)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {
	RegisterHandlersWithBaseURL(router, si, "")
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/v1/auth/application-token", wrapper.GetApplicationAuthenticationToken)
	router.POST(baseURL+"/v1/auth/application-token", wrapper.CreateNewAuthenticationToken)
	router.DELETE(baseURL+"/v1/auth/application-token/:id", wrapper.DeleteAuthenticationToken)
	router.GET(baseURL+"/v1/auth/groups", wrapper.FindGroups)
	router.GET(baseURL+"/v1/auth/me", wrapper.Me)
	router.GET(baseURL+"/v1/auth/root", wrapper.FindAllRoot)
	router.DELETE(baseURL+"/v1/auth/root/:email", wrapper.RemoveAsRootUser)
	router.POST(baseURL+"/v1/auth/root/:email", wrapper.SetRootUser)
	router.GET(baseURL+"/v1/auth/users", wrapper.FindPeople)
	router.GET(baseURL+"/v1/command", wrapper.ListAllCommand)
	router.POST(baseURL+"/v1/command", wrapper.CreateCommand)
	router.DELETE(baseURL+"/v1/command/:id", wrapper.DeleteCommandById)
	router.GET(baseURL+"/v1/command/:id", wrapper.FindCommandById)
	router.PUT(baseURL+"/v1/command/:id", wrapper.UpdateCommandById)
	router.GET(baseURL+"/v1/component", wrapper.ListAllComponent)
	router.POST(baseURL+"/v1/component", wrapper.Create)
	router.DELETE(baseURL+"/v1/component/:id", wrapper.DeleteById)
	router.GET(baseURL+"/v1/component/:id", wrapper.FindById)
	router.PUT(baseURL+"/v1/component/:id", wrapper.UpdateById)
	router.POST(baseURL+"/v1/debug", wrapper.DeleteAll)
	router.GET(baseURL+"/v1/echo/test/:value", wrapper.Echo)
	router.GET(baseURL+"/v1/mock/users-auth", wrapper.GetMockUser)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"H4sIAAAAAAAC/+xcTXPbONL+Kyi872mHspyZy6xOK39s1jX5cNlJpWpTPkBkS8IYBBgAtK249N+3APBb",
	"oERZlhMrvCS2CTW6n37Q3WiAesShiBPBgWuFR49YhXOIif1xnNArUCnTV6ASwRWMUz0HrmlINBX8k7gF",
	"fvbpoxmaSJGA1BTsB0FKIU9FBOaXCFQoaWI+gUf4QiE9B2RHoFBEgCToVHKI0FSKGJGE4gBPhYyJxiNM",
	"uf7jdxxgvUjA/QozkHgZuDnOREwo98zCUUgUIDHNZuJCI/iWEoa0QMcBIjx7EFkJKCQcTYwuiZAaIjRZ",
	"GE0CRHlkreUzdD8HCVb5RIoJgxhRhUQYplJCVKqotKR8Vmj4HpQiM9hFxdiJ6KYj0V3VS8iCCRIZzf5f",
	"whSP8P8NSyoMMx4MW3y+XAZYwreUGumjrxWX3xRzicnfEGoz1wqTToRgQHhPnddOHa+L7ghLK95xs5WC",
	"Jpnzd+TQqYhjwqNPECeMaOgj0YFHIo+/d2eQm6TnzuFzp/T0jqx5R5XuK6E+nWGqIVZPrZ8KPYiUZPFc",
	"nBSSfrcT9Wzs2djCxhpH9sDDRp6+TuOYyEVPyJ6Qm4u6Cln2w0w3f8/JnpMdisX9svGtFGnSU7CnoIeC",
	"BTf2wLtLkKovEHvieYlXkuOZmfeeJNfWBPdvz73Xzj0SRdSoRdhlzY9P6QiXEzzl0znrdiNoHxZ/iU5g",
	"JcDtxpc+jv26J1i5oO0Y1NozrqvwaQ6I1MYibQbjoME0kiQsG/GecDIDa0/zkC3AEBPKKo8qXnpIqCRu",
	"3seSeBHR4EONRl4pnMTgfeDUXn2ybEGn2b3041KMMvQxzkoVSGRQmhuXKZHKEFTpPOqe5C5fQbEq8pNV",
	"q4UURud8ztqnFPr6WYEMkC3bAzQuHXODAww8jQ09rsBO/0VSC+84iimvMKWJ84oOKaffUkA08ivh85i4",
	"5yBbDVKphR/ZUVsK7YyUE94JIDMGB9gOwgG2S8QLUO5lP0nypwg6muTjo/90uT7ZGUwpBxSBJpQpNDVR",
	"XQLRgAjicI+K9LNCutBJP3+AMLVKvSMLkMpnj1CASBZ8GVW68FPoQoOJeub3TCS6p4whTW6ha8lfKHFJ",
	"E2CUg6/6D7Bj34WTqGUKzWrN54rKX3K9q6B0Yr6RU3J+7cfzSLQqwDzpJCIhksSgW5xhwkj23IQdmxkq",
	"4D+x63mZy+yKfAfCXnClCQ/XEpdwRLNhFWwsi3QmBt1TPc/iZw6My45qhdQ7Oq8z8kM3P4pJ8kTAc3DW",
	"Ar8NyjVBLwR3N7IXcnyQW8l+GRnGTwqW3dBAivIZKzGoapq0byk7hpm1du8cJxqFX1VOJv1mM0z1U4g+",
	"tdRSS58JdskEtWtNXmbZ+q9YgOu5lGun8nDXgojl0EpIy2OeMns7sIwA8+MkpSyqu+Fox3i+TeWSAI8+",
	"8gKri2idUWJaVt9mXzalZcFcqpevGKrKPyI3k0KC16zb90Srm7GfqJzbbOKe1nQqmV/C56t3KwLQVyXD",
	"ABGp6ZSEOkCgw6ObzhnRd9T89KV46L7xgehNH1unSsiloCQTY8eQSqhudARkOKcaQp3KFpuqI6q9sVx+",
	"SDi6F/J2/YLfQsr61bw0W+gZ5V3KwUy4t2eXA5VF1w1xqpLtVFkrFNrbYiEL990C33YCN0JiXGo7g9cL",
	"pSH2z10MQsqOero3t5S0QX3fcqheGFidf2aeVlti3mwu+Ie2bl3qbe/5FPkA912bmR/g3tvMtEuQidlE",
	"iNsVRbdsS7b0H1s07xs7P6IS+IXq8erGsI0OgW/LWDPxppW9m2v7p/O2qPTXR+pmja9qbM2qJ8vXVMFT",
	"i3pvTyY4iD1JvwF5PWHnDqRq1Sd7uH3HqJ3FRTDIJ/ZFgtplha1OMLcqCWYQCuV90nqkqFLJd68wPicm",
	"2fepuk/VL9s6K3jXN9D6Btph5K8XanmZ0A9hKqleXBuOOYqfAJEgkdkt2hNCM/ccSGR3p844/DC4E2k4",
	"H9AoGZAwBKXy6y454gn9C8yeeBlgyqfCLSyuSajtbtHlIjyhCmac/kuR8MiweSpkdARRWs40vrxA12mS",
	"CGmQssDgudaJGg2HoeBTlgIP4UixhoRhRFXCyGJ4fn72ZXxm/vvtC0x+q1xjUKuXF0+FBHRi16jrQCAz",
	"v0lQBvJxGAIDSbSQ6IzeUVtGEI2u341P0QfiblbWRr0jE2F/MuzTVDNom6RSPIxw1grhJv2P8B9Hx0dv",
	"7E5Dz62HhndvhmaDPqzcJhoUF3dmYCHOehuCX0R4hN+Crlju6QRge0PD3pKzc/x+fJz7zJC0fnVp+Ldy",
	"q8WFpo1vsG3xOq5lTN0pH/9y5CUzZcqw2s2QgVFQCsZA4huTxYTyWH9qqwt/CwS7Ig+UPhHR4tlsbu+3",
	"LOt1ZRaGGuC/2R/43YF3sEVd0V8Ga5g5fKTR0gU1BhpWfXRm/+53ULU2+dpSPGcZBOpXrTwX8mxAM2up",
	"DDI0wk2XBBV4m4H05iXXyknxzRs7LIyqa2zTUbVGin9THr11QzYAT1V2uxSm9MFVhVqgKWWmSNR5e1Pl",
	"kH9LwYbBDHMFRIbGBz8JzrXXu54NbFcKeIF+Dy8ac6uXqJ/JOCmEXsujMWNXZsyPyC31V6af0+Thoy1f",
	"1kazK4jFHYyVMT+7ItlYS54w5Kqiw45EbSn6GvSLY/Xmh2C1Q1ZNVbY9b11xlyASBjtH7iQX81oi9/NG",
	"t7yr0Ya0jTGMnRbNj5c1ds0L+K3GKzcoUx4RxlZPBHCJUfZsm/K6isZe6mnvl0n92Fr6Oif82lVeYn/a",
	"1uZci3udlR0r6Qytk8VF1Cmgvu4auIT4yrbPy6siZU9uskBUq9VW02bat4bbQwK5bXntM5ykHlxr5wh7",
	"Rfb5o1TrGUinQPWTrCBnxHOuoDKAZQFvc2ItIuOLp9bV7xHZchXk38xbA8X9cZt8utdEWv1mvcNLoT6w",
	"mxzsmEZ/ufzpzHarPztgmCzQnCpkLdxI6dZceShJsrF0NsBpLG+CSXhHLNfkx9eaGLcMPAexKLLQE8Ek",
	"dV8+4I36WQOcMfwTNiqq9bUCl+r0HFBENKkAYE2cgRykmjKqF14cIJyLoQalh4/2xsuytRw4D+eiY/vf",
	"3Z2xR8T2JscEam+TG8hRIdx/CuDerFu3WJ5l5oRoDdII+EoG38eD/x4P/nnzD8957YsGtvY0vLIYzh9I",
	"nDBAJKHObAmE0e/2Zcnz0/98rPDBOBCdFhxAd29KGsQivHUdrQHJzprbji7fi/A26wy+HCLNbz/a3Fgy",
	"Fg2MRQ3a23N2eefn71vgxlqIkBuDUslqJ92j4TCcqNGfx38eY8OJbLamnGuQdzQEZBYW5bPs6lhGbY8f",
	"ljfL/wUAAP//HL649khiAAA=",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
