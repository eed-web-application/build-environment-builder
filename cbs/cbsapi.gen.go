// Package cbs provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen/v2 version v2.1.0 DO NOT EDIT.
package cbs

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

// Defines values for AuthorizationDTOAuthorizationType.
const (
	Admin AuthorizationDTOAuthorizationType = "Admin"
	Read  AuthorizationDTOAuthorizationType = "Read"
	Write AuthorizationDTOAuthorizationType = "Write"
)

// Defines values for AuthorizationDTOOwnerType.
const (
	Group AuthorizationDTOOwnerType = "Group"
	Token AuthorizationDTOOwnerType = "Token"
	User  AuthorizationDTOOwnerType = "User"
)

// ApiResultResponseAuthenticationTokenDTO defines model for ApiResultResponseAuthenticationTokenDTO.
type ApiResultResponseAuthenticationTokenDTO struct {
	// ErrorCode Is the error code returned from api
	ErrorCode int32 `json:"errorCode"`

	// ErrorDomain In case of error not equal to 0, an error domain can be reported by api, indicating where the problem is occurred
	ErrorDomain *string `json:"errorDomain,omitempty"`

	// ErrorMessage In case of error not equal to 0, an error message can be reported by api, indicating what problem is occurred
	ErrorMessage *string `json:"errorMessage,omitempty"`

	// Payload The authentication token
	Payload *AuthenticationTokenDTO `json:"payload,omitempty"`
}

// ApiResultResponseBoolean defines model for ApiResultResponseBoolean.
type ApiResultResponseBoolean struct {
	// ErrorCode Is the error code returned from api
	ErrorCode int32 `json:"errorCode"`

	// ErrorDomain In case of error not equal to 0, an error domain can be reported by api, indicating where the problem is occurred
	ErrorDomain *string `json:"errorDomain,omitempty"`

	// ErrorMessage In case of error not equal to 0, an error message can be reported by api, indicating what problem is occurred
	ErrorMessage *string `json:"errorMessage,omitempty"`

	// Payload Is the value returned by api
	Payload *bool `json:"payload,omitempty"`
}

// ApiResultResponseCommandTemplateDTO defines model for ApiResultResponseCommandTemplateDTO.
type ApiResultResponseCommandTemplateDTO struct {
	// ErrorCode Is the error code returned from api
	ErrorCode int32 `json:"errorCode"`

	// ErrorDomain In case of error not equal to 0, an error domain can be reported by api, indicating where the problem is occurred
	ErrorDomain *string `json:"errorDomain,omitempty"`

	// ErrorMessage In case of error not equal to 0, an error message can be reported by api, indicating what problem is occurred
	ErrorMessage *string `json:"errorMessage,omitempty"`

	// Payload Define details for create a new component
	Payload *CommandTemplateDTO `json:"payload,omitempty"`
}

// ApiResultResponseComponentDTO defines model for ApiResultResponseComponentDTO.
type ApiResultResponseComponentDTO struct {
	// ErrorCode Is the error code returned from api
	ErrorCode int32 `json:"errorCode"`

	// ErrorDomain In case of error not equal to 0, an error domain can be reported by api, indicating where the problem is occurred
	ErrorDomain *string `json:"errorDomain,omitempty"`

	// ErrorMessage In case of error not equal to 0, an error message can be reported by api, indicating what problem is occurred
	ErrorMessage *string `json:"errorMessage,omitempty"`

	// Payload Define the single component
	Payload *ComponentDTO `json:"payload,omitempty"`
}

// ApiResultResponseListAuthenticationTokenDTO defines model for ApiResultResponseListAuthenticationTokenDTO.
type ApiResultResponseListAuthenticationTokenDTO struct {
	// ErrorCode Is the error code returned from api
	ErrorCode int32 `json:"errorCode"`

	// ErrorDomain In case of error not equal to 0, an error domain can be reported by api, indicating where the problem is occurred
	ErrorDomain *string `json:"errorDomain,omitempty"`

	// ErrorMessage In case of error not equal to 0, an error message can be reported by api, indicating what problem is occurred
	ErrorMessage *string `json:"errorMessage,omitempty"`

	// Payload Is the value returned by api
	Payload *[]AuthenticationTokenDTO `json:"payload,omitempty"`
}

// ApiResultResponseListAuthorizationDTO defines model for ApiResultResponseListAuthorizationDTO.
type ApiResultResponseListAuthorizationDTO struct {
	// ErrorCode Is the error code returned from api
	ErrorCode int32 `json:"errorCode"`

	// ErrorDomain In case of error not equal to 0, an error domain can be reported by api, indicating where the problem is occurred
	ErrorDomain *string `json:"errorDomain,omitempty"`

	// ErrorMessage In case of error not equal to 0, an error message can be reported by api, indicating what problem is occurred
	ErrorMessage *string `json:"errorMessage,omitempty"`

	// Payload Is the value returned by api
	Payload *[]AuthorizationDTO `json:"payload,omitempty"`
}

// ApiResultResponseListCommandTemplateSummaryDTO defines model for ApiResultResponseListCommandTemplateSummaryDTO.
type ApiResultResponseListCommandTemplateSummaryDTO struct {
	// ErrorCode Is the error code returned from api
	ErrorCode int32 `json:"errorCode"`

	// ErrorDomain In case of error not equal to 0, an error domain can be reported by api, indicating where the problem is occurred
	ErrorDomain *string `json:"errorDomain,omitempty"`

	// ErrorMessage In case of error not equal to 0, an error message can be reported by api, indicating what problem is occurred
	ErrorMessage *string `json:"errorMessage,omitempty"`

	// Payload Is the value returned by api
	Payload *[]CommandTemplateSummaryDTO `json:"payload,omitempty"`
}

// ApiResultResponseListComponentSummaryDTO defines model for ApiResultResponseListComponentSummaryDTO.
type ApiResultResponseListComponentSummaryDTO struct {
	// ErrorCode Is the error code returned from api
	ErrorCode int32 `json:"errorCode"`

	// ErrorDomain In case of error not equal to 0, an error domain can be reported by api, indicating where the problem is occurred
	ErrorDomain *string `json:"errorDomain,omitempty"`

	// ErrorMessage In case of error not equal to 0, an error message can be reported by api, indicating what problem is occurred
	ErrorMessage *string `json:"errorMessage,omitempty"`

	// Payload Is the value returned by api
	Payload *[]ComponentSummaryDTO `json:"payload,omitempty"`
}

// ApiResultResponseListGroupDTO defines model for ApiResultResponseListGroupDTO.
type ApiResultResponseListGroupDTO struct {
	// ErrorCode Is the error code returned from api
	ErrorCode int32 `json:"errorCode"`

	// ErrorDomain In case of error not equal to 0, an error domain can be reported by api, indicating where the problem is occurred
	ErrorDomain *string `json:"errorDomain,omitempty"`

	// ErrorMessage In case of error not equal to 0, an error message can be reported by api, indicating what problem is occurred
	ErrorMessage *string `json:"errorMessage,omitempty"`

	// Payload Is the value returned by api
	Payload *[]GroupDTO `json:"payload,omitempty"`
}

// ApiResultResponseListPersonDTO defines model for ApiResultResponseListPersonDTO.
type ApiResultResponseListPersonDTO struct {
	// ErrorCode Is the error code returned from api
	ErrorCode int32 `json:"errorCode"`

	// ErrorDomain In case of error not equal to 0, an error domain can be reported by api, indicating where the problem is occurred
	ErrorDomain *string `json:"errorDomain,omitempty"`

	// ErrorMessage In case of error not equal to 0, an error message can be reported by api, indicating what problem is occurred
	ErrorMessage *string `json:"errorMessage,omitempty"`

	// Payload Is the value returned by api
	Payload *[]PersonDTO `json:"payload,omitempty"`
}

// ApiResultResponseMapStringString defines model for ApiResultResponseMapStringString.
type ApiResultResponseMapStringString struct {
	// ErrorCode Is the error code returned from api
	ErrorCode int32 `json:"errorCode"`

	// ErrorDomain In case of error not equal to 0, an error domain can be reported by api, indicating where the problem is occurred
	ErrorDomain *string `json:"errorDomain,omitempty"`

	// ErrorMessage In case of error not equal to 0, an error message can be reported by api, indicating what problem is occurred
	ErrorMessage *string `json:"errorMessage,omitempty"`

	// Payload Is the value returned by api
	Payload *map[string]string `json:"payload,omitempty"`
}

// ApiResultResponsePersonDTO defines model for ApiResultResponsePersonDTO.
type ApiResultResponsePersonDTO struct {
	// ErrorCode Is the error code returned from api
	ErrorCode int32 `json:"errorCode"`

	// ErrorDomain In case of error not equal to 0, an error domain can be reported by api, indicating where the problem is occurred
	ErrorDomain *string `json:"errorDomain,omitempty"`

	// ErrorMessage In case of error not equal to 0, an error message can be reported by api, indicating what problem is occurred
	ErrorMessage *string `json:"errorMessage,omitempty"`

	// Payload Is the value returned by api
	Payload *PersonDTO `json:"payload,omitempty"`
}

// ApiResultResponseString defines model for ApiResultResponseString.
type ApiResultResponseString struct {
	// ErrorCode Is the error code returned from api
	ErrorCode int32 `json:"errorCode"`

	// ErrorDomain In case of error not equal to 0, an error domain can be reported by api, indicating where the problem is occurred
	ErrorDomain *string `json:"errorDomain,omitempty"`

	// ErrorMessage In case of error not equal to 0, an error message can be reported by api, indicating what problem is occurred
	ErrorMessage *string `json:"errorMessage,omitempty"`

	// Payload Is the value returned by api
	Payload *string `json:"payload,omitempty"`
}

// AuthenticationTokenDTO The authentication token
type AuthenticationTokenDTO struct {
	ApplicationManaged *bool               `json:"applicationManaged,omitempty"`
	Email              *string             `json:"email,omitempty"`
	Expiration         *openapi_types.Date `json:"expiration,omitempty"`
	Id                 *string             `json:"id,omitempty"`
	Name               *string             `json:"name,omitempty"`
	Token              *string             `json:"token,omitempty"`
}

// AuthorizationDTO The authorization of the user on the resources returned in the payload
type AuthorizationDTO struct {
	// AuthorizationType Is the type of the authorizations [User, Group, Application]
	AuthorizationType *AuthorizationDTOAuthorizationType `json:"authorizationType,omitempty"`

	// Id Is unique id of the authorizations
	Id *string `json:"id,omitempty"`

	// Owner Is the subject owner of the authorizations
	Owner *string `json:"owner,omitempty"`

	// OwnerType Is the type of the owner [User, Group, Application]
	OwnerType *AuthorizationDTOOwnerType `json:"ownerType,omitempty"`

	// Resource The resource eof the authorizations
	Resource *string `json:"resource,omitempty"`
}

// AuthorizationDTOAuthorizationType Is the type of the authorizations [User, Group, Application]
type AuthorizationDTOAuthorizationType string

// AuthorizationDTOOwnerType Is the type of the owner [User, Group, Application]
type AuthorizationDTOOwnerType string

// CommandTemplateDTO Define details for create a new component
type CommandTemplateDTO struct {
	// CommandExecutionsLayers Those are the list of the action that the command will take
	CommandExecutionsLayers *[]ExecutionPipelineDTO `json:"commandExecutionsLayers,omitempty"`

	// Description The description of the component
	Description *string `json:"description,omitempty"`

	// Id The id of the component
	Id *string `json:"id,omitempty"`

	// Name The name of the component
	Name *string `json:"name,omitempty"`

	// Parameters The parameter used by the command
	Parameters *[]CommandTemplateParameterDTO `json:"parameters,omitempty"`
}

// CommandTemplateInstanceDTO Define an instance of the command template with the parameters values
type CommandTemplateInstanceDTO struct {
	// Id The id of the component
	Id *string `json:"id,omitempty"`

	// Parameters The parameter/values map
	Parameters *[]CommandTemplateInstanceParameterDTO `json:"parameters,omitempty"`
}

// CommandTemplateInstanceParameterDTO Define an instance of the command template with the parameters values
type CommandTemplateInstanceParameterDTO struct {
	// Name The name of the parameter
	Name *string `json:"name,omitempty"`

	// Value The values
	Value *string `json:"value,omitempty"`
}

// CommandTemplateParameterDTO Define a single command parameter
type CommandTemplateParameterDTO struct {
	// Description The description of the parameter
	Description string `json:"description"`

	// Name The name of the component
	Name string `json:"name"`
}

// CommandTemplateSummaryDTO Define details for create a new component
type CommandTemplateSummaryDTO struct {
	// CommandExecutionsLayers Those are the list of the action that the command will take
	CommandExecutionsLayers *[]ExecutionPipelineDTO `json:"commandExecutionsLayers,omitempty"`

	// Id The id of the component
	Id *string `json:"id,omitempty"`

	// Name The name of the component
	Name *string `json:"name,omitempty"`

	// Parameters The parameter used by the command
	Parameters *[]CommandTemplateParameterDTO `json:"parameters,omitempty"`
}

// ComponentDTO Define the single component
type ComponentDTO struct {
	// CommandTemplatesInstances The list command template instances to execute to build the component.
	CommandTemplatesInstances *[]CommandTemplateInstanceDTO `json:"commandTemplatesInstances,omitempty"`

	// DependOnComponentIds The list of unique identifier of the components that this component depends on.
	DependOnComponentIds *[]string `json:"dependOnComponentIds,omitempty"`

	// Description The description of the component
	Description *string `json:"description,omitempty"`

	// Id The unique identifier of the component
	Id *string `json:"id,omitempty"`

	// Name The name of the component
	Name *string `json:"name,omitempty"`

	// Url The URL of the component [src, artifact, etc.]
	Url *string `json:"url,omitempty"`
}

// ComponentSummaryDTO Define the single component
type ComponentSummaryDTO struct {
	// Description The description of the component
	Description *string `json:"description,omitempty"`

	// Id The unique identifier of the component
	Id *string `json:"id,omitempty"`

	// Name The name of the component
	Name *string `json:"name,omitempty"`
}

// ExecutionPipelineDTO Define details for create a new execution pipeline for a command
type ExecutionPipelineDTO struct {
	// Architecture The architecture where the pipeline can work
	Architecture *[]string `json:"architecture,omitempty"`

	// Engine The name of the pipeline
	Engine *string `json:"engine,omitempty"`

	// ExecutionCommands The list of the commands that the pipeline will execute
	ExecutionCommands *[]string `json:"executionCommands,omitempty"`

	// OperatingSystem The operating system where the pipeline can work
	OperatingSystem *[]string `json:"operatingSystem,omitempty"`
}

// GroupDTO The group of the user
type GroupDTO struct {
	CommonName *string `json:"commonName,omitempty"`
	Uid        *string `json:"uid,omitempty"`
}

// NewAuthenticationTokenDTO New authentication token for logbook
type NewAuthenticationTokenDTO struct {
	Expiration *openapi_types.Date `json:"expiration,omitempty"`
	Name       *string             `json:"name,omitempty"`
}

// NewCommandTemplateDTO Define details for create a new component
type NewCommandTemplateDTO struct {
	// CommandExecutionsLayers Those are the list of the action that the command will take
	CommandExecutionsLayers []ExecutionPipelineDTO `json:"commandExecutionsLayers"`

	// Description The description of the component
	Description string `json:"description"`

	// Name The name of the component
	Name string `json:"name"`

	// Parameters The parameter used by the command
	Parameters []CommandTemplateParameterDTO `json:"parameters"`
}

// NewComponentDTO Define details for create a new component
type NewComponentDTO struct {
	// CommandTemplates The list of command templates that the component will use.
	CommandTemplates *[]CommandTemplateDTO `json:"commandTemplates,omitempty"`

	// CommandTemplatesInstances The list command template instances to execute to build the component.
	CommandTemplatesInstances []CommandTemplateInstanceDTO `json:"commandTemplatesInstances"`

	// DependOnComponentIds The list of unique identifier of the components that this component depends on.
	DependOnComponentIds *[]string `json:"dependOnComponentIds,omitempty"`

	// Description The description of the component
	Description *string `json:"description,omitempty"`

	// Name The name of the component
	Name string `json:"name"`

	// Version The version of the component
	Version string `json:"version"`
}

// PersonDTO Is the value returned by api
type PersonDTO struct {
	CommonName *string `json:"commonName,omitempty"`
	Gecos      *string `json:"gecos,omitempty"`
	Mail       *string `json:"mail,omitempty"`
	Surname    *string `json:"surname,omitempty"`
	Uid        *string `json:"uid,omitempty"`
}

// UpdateCommandTemplateDTO Define details for create a new component
type UpdateCommandTemplateDTO struct {
	// CommandExecutionsLayers Those are the list of the action that the command will take
	CommandExecutionsLayers *[]ExecutionPipelineDTO `json:"commandExecutionsLayers,omitempty"`

	// Description The description of the component
	Description *string `json:"description,omitempty"`

	// Name The name of the component
	Name *string `json:"name,omitempty"`

	// Parameters The parameter used by the command
	Parameters *[]CommandTemplateParameterDTO `json:"parameters,omitempty"`
}

// UpdateComponentDTO Define the single component
type UpdateComponentDTO struct {
	// CommandTemplatesInstances The list command template instances to execute to build the component.
	CommandTemplatesInstances *[]CommandTemplateInstanceDTO `json:"commandTemplatesInstances,omitempty"`

	// DependOnComponentIds The list of unique identifier of the components that this component depends on.
	DependOnComponentIds *[]string `json:"dependOnComponentIds,omitempty"`

	// Description The description of the component
	Description *string `json:"description,omitempty"`

	// Name The name of the component
	Name *string `json:"name,omitempty"`

	// Url The URL of the component [src, artifact, etc.]
	Url *string `json:"url,omitempty"`
}

// FindGroupsParams defines parameters for FindGroups.
type FindGroupsParams struct {
	// Search is the prefix used to filter the groups
	Search *string `form:"search,omitempty" json:"search,omitempty"`
}

// FindPeopleParams defines parameters for FindPeople.
type FindPeopleParams struct {
	// Search is the prefix used to filter the people
	Search *string `form:"search,omitempty" json:"search,omitempty"`
}

// CreateNewAuthenticationTokenJSONRequestBody defines body for CreateNewAuthenticationToken for application/json ContentType.
type CreateNewAuthenticationTokenJSONRequestBody = NewAuthenticationTokenDTO

// Create1JSONRequestBody defines body for Create1 for application/json ContentType.
type Create1JSONRequestBody = NewCommandTemplateDTO

// UpdateById1JSONRequestBody defines body for UpdateById1 for application/json ContentType.
type UpdateById1JSONRequestBody = UpdateCommandTemplateDTO

// CreateJSONRequestBody defines body for Create for application/json ContentType.
type CreateJSONRequestBody = NewComponentDTO

// UpdateByIdJSONRequestBody defines body for UpdateById for application/json ContentType.
type UpdateByIdJSONRequestBody = UpdateComponentDTO

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// GetApplicationAuthenticationToken request
	GetApplicationAuthenticationToken(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateNewAuthenticationTokenWithBody request with any body
	CreateNewAuthenticationTokenWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateNewAuthenticationToken(ctx context.Context, body CreateNewAuthenticationTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteAuthenticationToken request
	DeleteAuthenticationToken(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindGroups request
	FindGroups(ctx context.Context, params *FindGroupsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Me request
	Me(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindAllRoot request
	FindAllRoot(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveAsRootUser request
	RemoveAsRootUser(ctx context.Context, email string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetRootUser request
	SetRootUser(ctx context.Context, email string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindPeople request
	FindPeople(ctx context.Context, params *FindPeopleParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListAllComponent1 request
	ListAllComponent1(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Create1WithBody request with any body
	Create1WithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	Create1(ctx context.Context, body Create1JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteById1 request
	DeleteById1(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindById1 request
	FindById1(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateById1WithBody request with any body
	UpdateById1WithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateById1(ctx context.Context, id string, body UpdateById1JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListAllComponent request
	ListAllComponent(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateWithBody request with any body
	CreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	Create(ctx context.Context, body CreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteById request
	DeleteById(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindById request
	FindById(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateByIdWithBody request with any body
	UpdateByIdWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateById(ctx context.Context, id string, body UpdateByIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Echo request
	Echo(ctx context.Context, value string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMockUser request
	GetMockUser(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) GetApplicationAuthenticationToken(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetApplicationAuthenticationTokenRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateNewAuthenticationTokenWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateNewAuthenticationTokenRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateNewAuthenticationToken(ctx context.Context, body CreateNewAuthenticationTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateNewAuthenticationTokenRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteAuthenticationToken(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteAuthenticationTokenRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindGroups(ctx context.Context, params *FindGroupsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindGroupsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Me(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMeRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindAllRoot(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindAllRootRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveAsRootUser(ctx context.Context, email string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveAsRootUserRequest(c.Server, email)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetRootUser(ctx context.Context, email string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetRootUserRequest(c.Server, email)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindPeople(ctx context.Context, params *FindPeopleParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindPeopleRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListAllComponent1(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListAllComponent1Request(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Create1WithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreate1RequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Create1(ctx context.Context, body Create1JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreate1Request(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteById1(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteById1Request(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindById1(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindById1Request(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateById1WithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateById1RequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateById1(ctx context.Context, id string, body UpdateById1JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateById1Request(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListAllComponent(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListAllComponentRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Create(ctx context.Context, body CreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteById(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteByIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindById(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindByIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateByIdWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateByIdRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateById(ctx context.Context, id string, body UpdateByIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateByIdRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Echo(ctx context.Context, value string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEchoRequest(c.Server, value)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMockUser(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMockUserRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewGetApplicationAuthenticationTokenRequest generates requests for GetApplicationAuthenticationToken
func NewGetApplicationAuthenticationTokenRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/auth/application-token")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateNewAuthenticationTokenRequest calls the generic CreateNewAuthenticationToken builder with application/json body
func NewCreateNewAuthenticationTokenRequest(server string, body CreateNewAuthenticationTokenJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateNewAuthenticationTokenRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateNewAuthenticationTokenRequestWithBody generates requests for CreateNewAuthenticationToken with any type of body
func NewCreateNewAuthenticationTokenRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/auth/application-token")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteAuthenticationTokenRequest generates requests for DeleteAuthenticationToken
func NewDeleteAuthenticationTokenRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/auth/application-token/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindGroupsRequest generates requests for FindGroups
func NewFindGroupsRequest(server string, params *FindGroupsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/auth/groups")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Search != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "search", runtime.ParamLocationQuery, *params.Search); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewMeRequest generates requests for Me
func NewMeRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/auth/me")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindAllRootRequest generates requests for FindAllRoot
func NewFindAllRootRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/auth/root")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRemoveAsRootUserRequest generates requests for RemoveAsRootUser
func NewRemoveAsRootUserRequest(server string, email string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "email", runtime.ParamLocationPath, email)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/auth/root/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetRootUserRequest generates requests for SetRootUser
func NewSetRootUserRequest(server string, email string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "email", runtime.ParamLocationPath, email)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/auth/root/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindPeopleRequest generates requests for FindPeople
func NewFindPeopleRequest(server string, params *FindPeopleParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/auth/users")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Search != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "search", runtime.ParamLocationQuery, *params.Search); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListAllComponent1Request generates requests for ListAllComponent1
func NewListAllComponent1Request(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/command")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreate1Request calls the generic Create1 builder with application/json body
func NewCreate1Request(server string, body Create1JSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreate1RequestWithBody(server, "application/json", bodyReader)
}

// NewCreate1RequestWithBody generates requests for Create1 with any type of body
func NewCreate1RequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/command")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteById1Request generates requests for DeleteById1
func NewDeleteById1Request(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/command/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindById1Request generates requests for FindById1
func NewFindById1Request(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/command/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateById1Request calls the generic UpdateById1 builder with application/json body
func NewUpdateById1Request(server string, id string, body UpdateById1JSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateById1RequestWithBody(server, id, "application/json", bodyReader)
}

// NewUpdateById1RequestWithBody generates requests for UpdateById1 with any type of body
func NewUpdateById1RequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/command/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListAllComponentRequest generates requests for ListAllComponent
func NewListAllComponentRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/component")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateRequest calls the generic Create builder with application/json body
func NewCreateRequest(server string, body CreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateRequestWithBody generates requests for Create with any type of body
func NewCreateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/component")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteByIdRequest generates requests for DeleteById
func NewDeleteByIdRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/component/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindByIdRequest generates requests for FindById
func NewFindByIdRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/component/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateByIdRequest calls the generic UpdateById builder with application/json body
func NewUpdateByIdRequest(server string, id string, body UpdateByIdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateByIdRequestWithBody(server, id, "application/json", bodyReader)
}

// NewUpdateByIdRequestWithBody generates requests for UpdateById with any type of body
func NewUpdateByIdRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/component/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewEchoRequest generates requests for Echo
func NewEchoRequest(server string, value string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "value", runtime.ParamLocationPath, value)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/echo/test/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetMockUserRequest generates requests for GetMockUser
func NewGetMockUserRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/mock/users-auth")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// GetApplicationAuthenticationTokenWithResponse request
	GetApplicationAuthenticationTokenWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetApplicationAuthenticationTokenResponse, error)

	// CreateNewAuthenticationTokenWithBodyWithResponse request with any body
	CreateNewAuthenticationTokenWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateNewAuthenticationTokenResponse, error)

	CreateNewAuthenticationTokenWithResponse(ctx context.Context, body CreateNewAuthenticationTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateNewAuthenticationTokenResponse, error)

	// DeleteAuthenticationTokenWithResponse request
	DeleteAuthenticationTokenWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteAuthenticationTokenResponse, error)

	// FindGroupsWithResponse request
	FindGroupsWithResponse(ctx context.Context, params *FindGroupsParams, reqEditors ...RequestEditorFn) (*FindGroupsResponse, error)

	// MeWithResponse request
	MeWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*MeResponse, error)

	// FindAllRootWithResponse request
	FindAllRootWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*FindAllRootResponse, error)

	// RemoveAsRootUserWithResponse request
	RemoveAsRootUserWithResponse(ctx context.Context, email string, reqEditors ...RequestEditorFn) (*RemoveAsRootUserResponse, error)

	// SetRootUserWithResponse request
	SetRootUserWithResponse(ctx context.Context, email string, reqEditors ...RequestEditorFn) (*SetRootUserResponse, error)

	// FindPeopleWithResponse request
	FindPeopleWithResponse(ctx context.Context, params *FindPeopleParams, reqEditors ...RequestEditorFn) (*FindPeopleResponse, error)

	// ListAllComponent1WithResponse request
	ListAllComponent1WithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListAllComponent1Response, error)

	// Create1WithBodyWithResponse request with any body
	Create1WithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*Create1Response, error)

	Create1WithResponse(ctx context.Context, body Create1JSONRequestBody, reqEditors ...RequestEditorFn) (*Create1Response, error)

	// DeleteById1WithResponse request
	DeleteById1WithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteById1Response, error)

	// FindById1WithResponse request
	FindById1WithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*FindById1Response, error)

	// UpdateById1WithBodyWithResponse request with any body
	UpdateById1WithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateById1Response, error)

	UpdateById1WithResponse(ctx context.Context, id string, body UpdateById1JSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateById1Response, error)

	// ListAllComponentWithResponse request
	ListAllComponentWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListAllComponentResponse, error)

	// CreateWithBodyWithResponse request with any body
	CreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateResponse, error)

	CreateWithResponse(ctx context.Context, body CreateJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateResponse, error)

	// DeleteByIdWithResponse request
	DeleteByIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteByIdResponse, error)

	// FindByIdWithResponse request
	FindByIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*FindByIdResponse, error)

	// UpdateByIdWithBodyWithResponse request with any body
	UpdateByIdWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateByIdResponse, error)

	UpdateByIdWithResponse(ctx context.Context, id string, body UpdateByIdJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateByIdResponse, error)

	// EchoWithResponse request
	EchoWithResponse(ctx context.Context, value string, reqEditors ...RequestEditorFn) (*EchoResponse, error)

	// GetMockUserWithResponse request
	GetMockUserWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetMockUserResponse, error)
}

type GetApplicationAuthenticationTokenResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ApiResultResponseListAuthenticationTokenDTO
}

// Status returns HTTPResponse.Status
func (r GetApplicationAuthenticationTokenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetApplicationAuthenticationTokenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateNewAuthenticationTokenResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *ApiResultResponseAuthenticationTokenDTO
}

// Status returns HTTPResponse.Status
func (r CreateNewAuthenticationTokenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateNewAuthenticationTokenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteAuthenticationTokenResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ApiResultResponseBoolean
}

// Status returns HTTPResponse.Status
func (r DeleteAuthenticationTokenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteAuthenticationTokenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindGroupsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ApiResultResponseListGroupDTO
}

// Status returns HTTPResponse.Status
func (r FindGroupsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindGroupsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ApiResultResponsePersonDTO
}

// Status returns HTTPResponse.Status
func (r MeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindAllRootResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ApiResultResponseListAuthorizationDTO
}

// Status returns HTTPResponse.Status
func (r FindAllRootResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindAllRootResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveAsRootUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ApiResultResponseBoolean
}

// Status returns HTTPResponse.Status
func (r RemoveAsRootUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveAsRootUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetRootUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *ApiResultResponseBoolean
}

// Status returns HTTPResponse.Status
func (r SetRootUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetRootUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindPeopleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ApiResultResponseListPersonDTO
}

// Status returns HTTPResponse.Status
func (r FindPeopleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindPeopleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListAllComponent1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ApiResultResponseListCommandTemplateSummaryDTO
}

// Status returns HTTPResponse.Status
func (r ListAllComponent1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListAllComponent1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type Create1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *ApiResultResponseString
}

// Status returns HTTPResponse.Status
func (r Create1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r Create1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteById1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ApiResultResponseBoolean
}

// Status returns HTTPResponse.Status
func (r DeleteById1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteById1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindById1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ApiResultResponseCommandTemplateDTO
}

// Status returns HTTPResponse.Status
func (r FindById1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindById1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateById1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ApiResultResponseBoolean
}

// Status returns HTTPResponse.Status
func (r UpdateById1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateById1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListAllComponentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ApiResultResponseListComponentSummaryDTO
}

// Status returns HTTPResponse.Status
func (r ListAllComponentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListAllComponentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *ApiResultResponseString
}

// Status returns HTTPResponse.Status
func (r CreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ApiResultResponseBoolean
}

// Status returns HTTPResponse.Status
func (r DeleteByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ApiResultResponseComponentDTO
}

// Status returns HTTPResponse.Status
func (r FindByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ApiResultResponseBoolean
}

// Status returns HTTPResponse.Status
func (r UpdateByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EchoResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ApiResultResponseString
}

// Status returns HTTPResponse.Status
func (r EchoResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EchoResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMockUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ApiResultResponseMapStringString
}

// Status returns HTTPResponse.Status
func (r GetMockUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMockUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetApplicationAuthenticationTokenWithResponse request returning *GetApplicationAuthenticationTokenResponse
func (c *ClientWithResponses) GetApplicationAuthenticationTokenWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetApplicationAuthenticationTokenResponse, error) {
	rsp, err := c.GetApplicationAuthenticationToken(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetApplicationAuthenticationTokenResponse(rsp)
}

// CreateNewAuthenticationTokenWithBodyWithResponse request with arbitrary body returning *CreateNewAuthenticationTokenResponse
func (c *ClientWithResponses) CreateNewAuthenticationTokenWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateNewAuthenticationTokenResponse, error) {
	rsp, err := c.CreateNewAuthenticationTokenWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateNewAuthenticationTokenResponse(rsp)
}

func (c *ClientWithResponses) CreateNewAuthenticationTokenWithResponse(ctx context.Context, body CreateNewAuthenticationTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateNewAuthenticationTokenResponse, error) {
	rsp, err := c.CreateNewAuthenticationToken(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateNewAuthenticationTokenResponse(rsp)
}

// DeleteAuthenticationTokenWithResponse request returning *DeleteAuthenticationTokenResponse
func (c *ClientWithResponses) DeleteAuthenticationTokenWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteAuthenticationTokenResponse, error) {
	rsp, err := c.DeleteAuthenticationToken(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteAuthenticationTokenResponse(rsp)
}

// FindGroupsWithResponse request returning *FindGroupsResponse
func (c *ClientWithResponses) FindGroupsWithResponse(ctx context.Context, params *FindGroupsParams, reqEditors ...RequestEditorFn) (*FindGroupsResponse, error) {
	rsp, err := c.FindGroups(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindGroupsResponse(rsp)
}

// MeWithResponse request returning *MeResponse
func (c *ClientWithResponses) MeWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*MeResponse, error) {
	rsp, err := c.Me(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMeResponse(rsp)
}

// FindAllRootWithResponse request returning *FindAllRootResponse
func (c *ClientWithResponses) FindAllRootWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*FindAllRootResponse, error) {
	rsp, err := c.FindAllRoot(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindAllRootResponse(rsp)
}

// RemoveAsRootUserWithResponse request returning *RemoveAsRootUserResponse
func (c *ClientWithResponses) RemoveAsRootUserWithResponse(ctx context.Context, email string, reqEditors ...RequestEditorFn) (*RemoveAsRootUserResponse, error) {
	rsp, err := c.RemoveAsRootUser(ctx, email, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveAsRootUserResponse(rsp)
}

// SetRootUserWithResponse request returning *SetRootUserResponse
func (c *ClientWithResponses) SetRootUserWithResponse(ctx context.Context, email string, reqEditors ...RequestEditorFn) (*SetRootUserResponse, error) {
	rsp, err := c.SetRootUser(ctx, email, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetRootUserResponse(rsp)
}

// FindPeopleWithResponse request returning *FindPeopleResponse
func (c *ClientWithResponses) FindPeopleWithResponse(ctx context.Context, params *FindPeopleParams, reqEditors ...RequestEditorFn) (*FindPeopleResponse, error) {
	rsp, err := c.FindPeople(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindPeopleResponse(rsp)
}

// ListAllComponent1WithResponse request returning *ListAllComponent1Response
func (c *ClientWithResponses) ListAllComponent1WithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListAllComponent1Response, error) {
	rsp, err := c.ListAllComponent1(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListAllComponent1Response(rsp)
}

// Create1WithBodyWithResponse request with arbitrary body returning *Create1Response
func (c *ClientWithResponses) Create1WithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*Create1Response, error) {
	rsp, err := c.Create1WithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreate1Response(rsp)
}

func (c *ClientWithResponses) Create1WithResponse(ctx context.Context, body Create1JSONRequestBody, reqEditors ...RequestEditorFn) (*Create1Response, error) {
	rsp, err := c.Create1(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreate1Response(rsp)
}

// DeleteById1WithResponse request returning *DeleteById1Response
func (c *ClientWithResponses) DeleteById1WithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteById1Response, error) {
	rsp, err := c.DeleteById1(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteById1Response(rsp)
}

// FindById1WithResponse request returning *FindById1Response
func (c *ClientWithResponses) FindById1WithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*FindById1Response, error) {
	rsp, err := c.FindById1(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindById1Response(rsp)
}

// UpdateById1WithBodyWithResponse request with arbitrary body returning *UpdateById1Response
func (c *ClientWithResponses) UpdateById1WithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateById1Response, error) {
	rsp, err := c.UpdateById1WithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateById1Response(rsp)
}

func (c *ClientWithResponses) UpdateById1WithResponse(ctx context.Context, id string, body UpdateById1JSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateById1Response, error) {
	rsp, err := c.UpdateById1(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateById1Response(rsp)
}

// ListAllComponentWithResponse request returning *ListAllComponentResponse
func (c *ClientWithResponses) ListAllComponentWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListAllComponentResponse, error) {
	rsp, err := c.ListAllComponent(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListAllComponentResponse(rsp)
}

// CreateWithBodyWithResponse request with arbitrary body returning *CreateResponse
func (c *ClientWithResponses) CreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateResponse, error) {
	rsp, err := c.CreateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateResponse(rsp)
}

func (c *ClientWithResponses) CreateWithResponse(ctx context.Context, body CreateJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateResponse, error) {
	rsp, err := c.Create(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateResponse(rsp)
}

// DeleteByIdWithResponse request returning *DeleteByIdResponse
func (c *ClientWithResponses) DeleteByIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteByIdResponse, error) {
	rsp, err := c.DeleteById(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteByIdResponse(rsp)
}

// FindByIdWithResponse request returning *FindByIdResponse
func (c *ClientWithResponses) FindByIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*FindByIdResponse, error) {
	rsp, err := c.FindById(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindByIdResponse(rsp)
}

// UpdateByIdWithBodyWithResponse request with arbitrary body returning *UpdateByIdResponse
func (c *ClientWithResponses) UpdateByIdWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateByIdResponse, error) {
	rsp, err := c.UpdateByIdWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateByIdResponse(rsp)
}

func (c *ClientWithResponses) UpdateByIdWithResponse(ctx context.Context, id string, body UpdateByIdJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateByIdResponse, error) {
	rsp, err := c.UpdateById(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateByIdResponse(rsp)
}

// EchoWithResponse request returning *EchoResponse
func (c *ClientWithResponses) EchoWithResponse(ctx context.Context, value string, reqEditors ...RequestEditorFn) (*EchoResponse, error) {
	rsp, err := c.Echo(ctx, value, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEchoResponse(rsp)
}

// GetMockUserWithResponse request returning *GetMockUserResponse
func (c *ClientWithResponses) GetMockUserWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetMockUserResponse, error) {
	rsp, err := c.GetMockUser(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMockUserResponse(rsp)
}

// ParseGetApplicationAuthenticationTokenResponse parses an HTTP response from a GetApplicationAuthenticationTokenWithResponse call
func ParseGetApplicationAuthenticationTokenResponse(rsp *http.Response) (*GetApplicationAuthenticationTokenResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetApplicationAuthenticationTokenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ApiResultResponseListAuthenticationTokenDTO
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateNewAuthenticationTokenResponse parses an HTTP response from a CreateNewAuthenticationTokenWithResponse call
func ParseCreateNewAuthenticationTokenResponse(rsp *http.Response) (*CreateNewAuthenticationTokenResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateNewAuthenticationTokenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest ApiResultResponseAuthenticationTokenDTO
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseDeleteAuthenticationTokenResponse parses an HTTP response from a DeleteAuthenticationTokenWithResponse call
func ParseDeleteAuthenticationTokenResponse(rsp *http.Response) (*DeleteAuthenticationTokenResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteAuthenticationTokenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ApiResultResponseBoolean
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseFindGroupsResponse parses an HTTP response from a FindGroupsWithResponse call
func ParseFindGroupsResponse(rsp *http.Response) (*FindGroupsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindGroupsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ApiResultResponseListGroupDTO
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseMeResponse parses an HTTP response from a MeWithResponse call
func ParseMeResponse(rsp *http.Response) (*MeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ApiResultResponsePersonDTO
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseFindAllRootResponse parses an HTTP response from a FindAllRootWithResponse call
func ParseFindAllRootResponse(rsp *http.Response) (*FindAllRootResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindAllRootResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ApiResultResponseListAuthorizationDTO
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseRemoveAsRootUserResponse parses an HTTP response from a RemoveAsRootUserWithResponse call
func ParseRemoveAsRootUserResponse(rsp *http.Response) (*RemoveAsRootUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemoveAsRootUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ApiResultResponseBoolean
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseSetRootUserResponse parses an HTTP response from a SetRootUserWithResponse call
func ParseSetRootUserResponse(rsp *http.Response) (*SetRootUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetRootUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest ApiResultResponseBoolean
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseFindPeopleResponse parses an HTTP response from a FindPeopleWithResponse call
func ParseFindPeopleResponse(rsp *http.Response) (*FindPeopleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindPeopleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ApiResultResponseListPersonDTO
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListAllComponent1Response parses an HTTP response from a ListAllComponent1WithResponse call
func ParseListAllComponent1Response(rsp *http.Response) (*ListAllComponent1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListAllComponent1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ApiResultResponseListCommandTemplateSummaryDTO
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreate1Response parses an HTTP response from a Create1WithResponse call
func ParseCreate1Response(rsp *http.Response) (*Create1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Create1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest ApiResultResponseString
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseDeleteById1Response parses an HTTP response from a DeleteById1WithResponse call
func ParseDeleteById1Response(rsp *http.Response) (*DeleteById1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteById1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ApiResultResponseBoolean
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseFindById1Response parses an HTTP response from a FindById1WithResponse call
func ParseFindById1Response(rsp *http.Response) (*FindById1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindById1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ApiResultResponseCommandTemplateDTO
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateById1Response parses an HTTP response from a UpdateById1WithResponse call
func ParseUpdateById1Response(rsp *http.Response) (*UpdateById1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateById1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ApiResultResponseBoolean
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListAllComponentResponse parses an HTTP response from a ListAllComponentWithResponse call
func ParseListAllComponentResponse(rsp *http.Response) (*ListAllComponentResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListAllComponentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ApiResultResponseListComponentSummaryDTO
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateResponse parses an HTTP response from a CreateWithResponse call
func ParseCreateResponse(rsp *http.Response) (*CreateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest ApiResultResponseString
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseDeleteByIdResponse parses an HTTP response from a DeleteByIdWithResponse call
func ParseDeleteByIdResponse(rsp *http.Response) (*DeleteByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ApiResultResponseBoolean
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseFindByIdResponse parses an HTTP response from a FindByIdWithResponse call
func ParseFindByIdResponse(rsp *http.Response) (*FindByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ApiResultResponseComponentDTO
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateByIdResponse parses an HTTP response from a UpdateByIdWithResponse call
func ParseUpdateByIdResponse(rsp *http.Response) (*UpdateByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ApiResultResponseBoolean
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseEchoResponse parses an HTTP response from a EchoWithResponse call
func ParseEchoResponse(rsp *http.Response) (*EchoResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EchoResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ApiResultResponseString
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetMockUserResponse parses an HTTP response from a GetMockUserWithResponse call
func ParseGetMockUserResponse(rsp *http.Response) (*GetMockUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMockUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ApiResultResponseMapStringString
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ServerInterface represents all server handlers.
type ServerInterface interface {

	// (GET /v1/auth/application-token)
	GetApplicationAuthenticationToken(ctx echo.Context) error

	// (POST /v1/auth/application-token)
	CreateNewAuthenticationToken(ctx echo.Context) error

	// (DELETE /v1/auth/application-token/{id})
	DeleteAuthenticationToken(ctx echo.Context, id string) error

	// (GET /v1/auth/groups)
	FindGroups(ctx echo.Context, params FindGroupsParams) error

	// (GET /v1/auth/me)
	Me(ctx echo.Context) error

	// (GET /v1/auth/root)
	FindAllRoot(ctx echo.Context) error

	// (DELETE /v1/auth/root/{email})
	RemoveAsRootUser(ctx echo.Context, email string) error

	// (POST /v1/auth/root/{email})
	SetRootUser(ctx echo.Context, email string) error

	// (GET /v1/auth/users)
	FindPeople(ctx echo.Context, params FindPeopleParams) error
	// List all command templates
	// (GET /v1/command)
	ListAllComponent1(ctx echo.Context) error
	// Create a new component
	// (POST /v1/command)
	Create1(ctx echo.Context) error
	// Return a command template by its unique identifier
	// (DELETE /v1/command/{id})
	DeleteById1(ctx echo.Context, id string) error
	// List all command templates
	// (GET /v1/command/{id})
	FindById1(ctx echo.Context, id string) error
	// Update a command template by its unique identifier
	// (PUT /v1/command/{id})
	UpdateById1(ctx echo.Context, id string) error
	// List all components
	// (GET /v1/component)
	ListAllComponent(ctx echo.Context) error
	// Create a new component
	// (POST /v1/component)
	Create(ctx echo.Context) error
	// Delete a component by his id
	// (DELETE /v1/component/{id})
	DeleteById(ctx echo.Context, id string) error
	// Find a component by an id
	// (GET /v1/component/{id})
	FindById(ctx echo.Context, id string) error
	// Delete a component by his id
	// (PUT /v1/component/{id})
	UpdateById(ctx echo.Context, id string) error
	// Example api that realize an ECHO
	// (GET /v1/echo/test/{value})
	Echo(ctx echo.Context, value string) error

	// (GET /v1/mock/users-auth)
	GetMockUser(ctx echo.Context) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// GetApplicationAuthenticationToken converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationAuthenticationToken(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetApplicationAuthenticationToken(ctx)
	return err
}

// CreateNewAuthenticationToken converts echo context to params.
func (w *ServerInterfaceWrapper) CreateNewAuthenticationToken(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.CreateNewAuthenticationToken(ctx)
	return err
}

// DeleteAuthenticationToken converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteAuthenticationToken(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteAuthenticationToken(ctx, id)
	return err
}

// FindGroups converts echo context to params.
func (w *ServerInterfaceWrapper) FindGroups(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params FindGroupsParams
	// ------------- Optional query parameter "search" -------------

	err = runtime.BindQueryParameter("form", true, false, "search", ctx.QueryParams(), &params.Search)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter search: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.FindGroups(ctx, params)
	return err
}

// Me converts echo context to params.
func (w *ServerInterfaceWrapper) Me(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.Me(ctx)
	return err
}

// FindAllRoot converts echo context to params.
func (w *ServerInterfaceWrapper) FindAllRoot(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.FindAllRoot(ctx)
	return err
}

// RemoveAsRootUser converts echo context to params.
func (w *ServerInterfaceWrapper) RemoveAsRootUser(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "email" -------------
	var email string

	err = runtime.BindStyledParameterWithOptions("simple", "email", ctx.Param("email"), &email, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter email: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.RemoveAsRootUser(ctx, email)
	return err
}

// SetRootUser converts echo context to params.
func (w *ServerInterfaceWrapper) SetRootUser(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "email" -------------
	var email string

	err = runtime.BindStyledParameterWithOptions("simple", "email", ctx.Param("email"), &email, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter email: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.SetRootUser(ctx, email)
	return err
}

// FindPeople converts echo context to params.
func (w *ServerInterfaceWrapper) FindPeople(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params FindPeopleParams
	// ------------- Optional query parameter "search" -------------

	err = runtime.BindQueryParameter("form", true, false, "search", ctx.QueryParams(), &params.Search)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter search: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.FindPeople(ctx, params)
	return err
}

// ListAllComponent1 converts echo context to params.
func (w *ServerInterfaceWrapper) ListAllComponent1(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ListAllComponent1(ctx)
	return err
}

// Create1 converts echo context to params.
func (w *ServerInterfaceWrapper) Create1(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.Create1(ctx)
	return err
}

// DeleteById1 converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteById1(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteById1(ctx, id)
	return err
}

// FindById1 converts echo context to params.
func (w *ServerInterfaceWrapper) FindById1(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.FindById1(ctx, id)
	return err
}

// UpdateById1 converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateById1(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.UpdateById1(ctx, id)
	return err
}

// ListAllComponent converts echo context to params.
func (w *ServerInterfaceWrapper) ListAllComponent(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ListAllComponent(ctx)
	return err
}

// Create converts echo context to params.
func (w *ServerInterfaceWrapper) Create(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.Create(ctx)
	return err
}

// DeleteById converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteById(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteById(ctx, id)
	return err
}

// FindById converts echo context to params.
func (w *ServerInterfaceWrapper) FindById(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.FindById(ctx, id)
	return err
}

// UpdateById converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateById(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.UpdateById(ctx, id)
	return err
}

// Echo converts echo context to params.
func (w *ServerInterfaceWrapper) Echo(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "value" -------------
	var value string

	err = runtime.BindStyledParameterWithOptions("simple", "value", ctx.Param("value"), &value, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter value: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.Echo(ctx, value)
	return err
}

// GetMockUser converts echo context to params.
func (w *ServerInterfaceWrapper) GetMockUser(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetMockUser(ctx)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {
	RegisterHandlersWithBaseURL(router, si, "")
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/v1/auth/application-token", wrapper.GetApplicationAuthenticationToken)
	router.POST(baseURL+"/v1/auth/application-token", wrapper.CreateNewAuthenticationToken)
	router.DELETE(baseURL+"/v1/auth/application-token/:id", wrapper.DeleteAuthenticationToken)
	router.GET(baseURL+"/v1/auth/groups", wrapper.FindGroups)
	router.GET(baseURL+"/v1/auth/me", wrapper.Me)
	router.GET(baseURL+"/v1/auth/root", wrapper.FindAllRoot)
	router.DELETE(baseURL+"/v1/auth/root/:email", wrapper.RemoveAsRootUser)
	router.POST(baseURL+"/v1/auth/root/:email", wrapper.SetRootUser)
	router.GET(baseURL+"/v1/auth/users", wrapper.FindPeople)
	router.GET(baseURL+"/v1/command", wrapper.ListAllComponent1)
	router.POST(baseURL+"/v1/command", wrapper.Create1)
	router.DELETE(baseURL+"/v1/command/:id", wrapper.DeleteById1)
	router.GET(baseURL+"/v1/command/:id", wrapper.FindById1)
	router.PUT(baseURL+"/v1/command/:id", wrapper.UpdateById1)
	router.GET(baseURL+"/v1/component", wrapper.ListAllComponent)
	router.POST(baseURL+"/v1/component", wrapper.Create)
	router.DELETE(baseURL+"/v1/component/:id", wrapper.DeleteById)
	router.GET(baseURL+"/v1/component/:id", wrapper.FindById)
	router.PUT(baseURL+"/v1/component/:id", wrapper.UpdateById)
	router.GET(baseURL+"/v1/echo/test/:value", wrapper.Echo)
	router.GET(baseURL+"/v1/mock/users-auth", wrapper.GetMockUser)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"H4sIAAAAAAAC/+xcW1PjOvL/Kir//097HALnvJzN04bLzlJnLhQwNVVL8aDInUQHW/JIMpCh8t23JPke",
	"OXFuMGT8MgNYaXX/+qfuVkvOi0d4FHMGTElv8OJJMoUImx+HMb0GmYTqGmTMmYRhoqbAFCVYUc5u+QOw",
	"89svemgseAxCUTAfBCG4OOMB6F8CkETQWH/CG3iXEqkpIDMCER4AEqASwSBAY8EjhGPq+d6Yiwgrb+BR",
	"pv743fM9NYvB/goTEN7ct3Oc8whT5piFIYIlID5OZ2JcIfie4BApjo59hFn6IDASEMEMjbQuMRcKAjSa",
	"aU18RFlgrGUT9DQFAUb5WPBRCBGiEnFCEiEgKFSUSlA2yTX8BFLiCWyjYmRFtNMRq7bqxXgWchxozf5f",
	"wNgbeP/XL6jQT3nQb/D5fO57Ar4nVEsf3JVcfp/PxUd/A1F6rgUmnXIeAmYddd47dZwuesRhUvKOna0Q",
	"NEqdvyWHzngUYRbcQhSHWEEXiQ48Ejn8vT2D7CQddw6fO4Wnt2TNRypVVwl16cyjCiK5af2U64GFwLNd",
	"cZIL+sNM1LGxY2MDGysc2QMPa3n6JokiLGYdITtCri7qSmTZDzPt/B0nO062KBb3y8YPgidxR8GOgg4K",
	"5tzYA++uQMiuQOyI5yReQY4dM+8Tjm+MCfbfjnvvnXs4CKhWC4dXFT9u0hEuJtjk0xnrtiNoFxZ/iU5g",
	"KcBtx5cujv26J1iZoPUY1NgzrqpwOwWEK2OR0oM9v8Y0HMdhOuITZngCxp76IZvvQYRpWHpU8tJzTAW2",
	"874UxAuwAhdqNHBKYTgC5wOr9uKTeQM69e6lG5d8lKaPdlYiQSCN0lS7TPJEEJCF86h9krl8AcWyyFuj",
	"VgMptM7ZnJVPSXT3VYLwkSnbfTQsHHPv+R6wJNL0uAYz/TdBDbzDIKKsxJQ6zgs6JIx+TwDRwK2Ey2P8",
	"iYFoNEgmBn5kRq0ptDVSVngrgPQYz/fMIM/3zBJxApR52U2S7CmClia5+Og+Xa5Odg5jygAFoDANJRrr",
	"qC4AK0AYMXhCefpZIB2x0i+egSRGqY94BkK67OESEE6Db0ilyv1EbGjQUU//nopETzQMkcIP0Lbkz5W4",
	"ojGElIGr+vc9y75LK1GJBOrVmssVpb9kepdBacV8Lafg/NKPZ5FoUYB+0kpEjAWOQDU4Q4eR9LkOOyYz",
	"lMDfsOt5lclsi3wLwl4yqTAjS4mLGaLpsBI2hkUqFYOeqJqm8TMDxmZHuUDqLZ3XGvm+nR9FON4Q8Ayc",
	"pcCvg3JF0CvB3Y7suRwX5EayW0aK8UbBsh0aSFI2CQsMyprGzVvKlmFmqd1bx4la4VeWk0q/Xw1T9RSi",
	"Sy2V1NJlgm0yQeVak5NZpv7LF+ByLmXaySzcNSBiOLQQ0rKYJ/XeDgwjQP84SmgYVN1wtGU8X6dyiYEF",
	"X1iO1WWwzCg+LqpvvS8b06JgLtTLVgyVxR+RnUkizirW7Xuixc3YT1TOrTZxT2s6EaFbwtfrjwsC0J0U",
	"xEdYKDrGRPkIFDm6b50RXUfNmy/FQ/eNC0Rn+lg7VUImBcWpGDMGl0J1rSMgyJQqICoRDTaVR5R7Y5l8",
	"ghl64uJh+YJfQ8ry1TzXW+gJZW3KwVS4s2eXAZVG1xVxqpTtZFEr5NqbYiEN9+0C33oCV0KiXWo6gzcz",
	"qSByz50PQtKM2tyba0paob5rOZQvDCzOP9FPyy0xZzbn7HNTty5xtvdcinyGp7bNzM/w5GxmmiUY8smI",
	"84cFRddsSzb0Hxs07xo7b1EJ/EL1eHlj2EQH37VlrJh438je1bX95rzNK/3lkbpe48sKW9PqyfA1kbBp",
	"Ue/syfgHsSfpNiDvJ+w8gpCN+qQP1+8YNbM4DwbZxK5IULmssNYJ5lolwQQIl84njUeKMhFs+wrja6yT",
	"fZequ1T9uq2znHddA61roB1G/nqllpcO/UASQdXsRnPMUvwUsACB9G7RnBDquaeAA7M7tcZ5z71HnpBp",
	"jwZxDxMCUmbXXTLEY/oX6D3x3PcoG3O7sJjCRJndos1F3ohKmDD6L4nJkWbzmIvgCIKkmGl4dYlukjjm",
	"QiNlgPGmSsVy0O8TzsZhAozAkQxrEvoBlXGIZ/2Li/Nvw3P932/fYPRb6RqDXLy8eMYFoFOzRm0HAun5",
	"dYLSkA8JgRAEVlygc/pITRmBFbr5ODxDn7G9WVkZ9RGPuPlJs09RFULTJKXiYeClrRCm0//A++Po+OjE",
	"7DTU1Hio/3jS1xv0fuk2US+/uDMBA3Ha2+DsMvAG3gdQJcsdnQDP3NAwt+TMHL8fH2c+0yStXl3q/y3t",
	"arGhaeUbbGu8jmsYU3XKl78sefFE6jKscjOkpxUUPAxBePc6i3HpsP7MVBfuFohnizyQ6pQHs53Z3Nxv",
	"mVfryjQM1cA/2R/47YG3sAVt0Z/7S5jZf6HB3Aa1EBQs+ujc/N3toHJtctdQPKcZBKpXrRwX8kxA02up",
	"CDI08Oou8Uvw1gPp/WuuldP8mze2WBhl15imo2yMFP+mLPhgh6wAnsr0dimM6bOtChVHYxrqIlFl7U2Z",
	"Qf49ARMGU8wlYEG0D34SnCuvd+0MbFsKOIH+BK8ac8uXqHdknOBcLeXRMAyv9Zi3yC3VV6Z3aXL/xZQv",
	"S6PZNUT8EYZSm59ekaytJUcYslXRYUeiphR9A+rVsTp5E6y2yKqJTLfnjSvuCngcwtaRO87EvJfIvdvo",
	"lnU1mpA2MSYM8330yatHuCXv4DfaL+2gVH+Ew3DxUMArYEqfrVNhn+yvmHZ+k9TbFtI3GduXLvEC9bOm",
	"HudSxKuUbFlGn84ug5NWcfR9l74FuNema17cEClacaMZokoudphWU70xyh4GvE1Lap/BI3Egahu4+8V0",
	"9zGp8bijVVj6SVaNNWKXq6YIV2l4a5tD3yKFLn5lyJr8z76EtwKK/eM6eXOvabP8JXqHlzBdYNc5uEbS",
	"/KVypjXbrv70LGE0Q1MqkbFwJaWX5sdDSI+1pbMCTm15HUzMWmK5IjO+x8S4ZuA5iEWRhh4gU95XIFX/",
	"xVzqmDemwQsy5S073PZ6iDkFNZcVRlB5YVonGJQLdze67ctjy0iyk5ljrBQILeAO934Me/897v3z/h+O",
	"I8lXXdDN6WeBBBfPOIpDQDim1mwBOKQ/zPuAF2f/+VIignYgOss5gB5PChpEnDzYpk0Pp8epTadznzh5",
	"SJtfr4dI/Qt+VvdOtEU9bVGN9uYoWTy6+fsBmLYWAmTHoESElcPcQb9PRnLw5/Gfx57mRDpbXc4NiEdK",
	"AOmFRdkkvR2VUtvhh/n9/H8BAAD//5vTNswrYQAA",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
