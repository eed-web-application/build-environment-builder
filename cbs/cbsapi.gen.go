// Package cbs provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen/v2 version v2.1.0 DO NOT EDIT.
package cbs

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

// Defines values for AuthorizationDTOAuthorizationType.
const (
	Admin AuthorizationDTOAuthorizationType = "Admin"
	Read  AuthorizationDTOAuthorizationType = "Read"
	Write AuthorizationDTOAuthorizationType = "Write"
)

// Defines values for AuthorizationDTOOwnerType.
const (
	Group AuthorizationDTOOwnerType = "Group"
	Token AuthorizationDTOOwnerType = "Token"
	User  AuthorizationDTOOwnerType = "User"
)

// ApiResultResponseAuthenticationTokenDTO defines model for ApiResultResponseAuthenticationTokenDTO.
type ApiResultResponseAuthenticationTokenDTO struct {
	// ErrorCode Is the error code returned from api
	ErrorCode int32 `json:"errorCode"`

	// ErrorDomain In case of error not equal to 0, an error domain can be reported by api, indicating where the problem is occurred
	ErrorDomain *string `json:"errorDomain,omitempty"`

	// ErrorMessage In case of error not equal to 0, an error message can be reported by api, indicating what problem is occurred
	ErrorMessage *string `json:"errorMessage,omitempty"`

	// Payload The authentication token
	Payload *AuthenticationTokenDTO `json:"payload,omitempty"`
}

// ApiResultResponseBoolean defines model for ApiResultResponseBoolean.
type ApiResultResponseBoolean struct {
	// ErrorCode Is the error code returned from api
	ErrorCode int32 `json:"errorCode"`

	// ErrorDomain In case of error not equal to 0, an error domain can be reported by api, indicating where the problem is occurred
	ErrorDomain *string `json:"errorDomain,omitempty"`

	// ErrorMessage In case of error not equal to 0, an error message can be reported by api, indicating what problem is occurred
	ErrorMessage *string `json:"errorMessage,omitempty"`

	// Payload Is the value returned by api
	Payload *bool `json:"payload,omitempty"`
}

// ApiResultResponseCommandTemplateDTO defines model for ApiResultResponseCommandTemplateDTO.
type ApiResultResponseCommandTemplateDTO struct {
	// ErrorCode Is the error code returned from api
	ErrorCode int32 `json:"errorCode"`

	// ErrorDomain In case of error not equal to 0, an error domain can be reported by api, indicating where the problem is occurred
	ErrorDomain *string `json:"errorDomain,omitempty"`

	// ErrorMessage In case of error not equal to 0, an error message can be reported by api, indicating what problem is occurred
	ErrorMessage *string `json:"errorMessage,omitempty"`

	// Payload Define details for create a new component
	Payload *CommandTemplateDTO `json:"payload,omitempty"`
}

// ApiResultResponseComponentDTO defines model for ApiResultResponseComponentDTO.
type ApiResultResponseComponentDTO struct {
	// ErrorCode Is the error code returned from api
	ErrorCode int32 `json:"errorCode"`

	// ErrorDomain In case of error not equal to 0, an error domain can be reported by api, indicating where the problem is occurred
	ErrorDomain *string `json:"errorDomain,omitempty"`

	// ErrorMessage In case of error not equal to 0, an error message can be reported by api, indicating what problem is occurred
	ErrorMessage *string `json:"errorMessage,omitempty"`

	// Payload Define the single component
	Payload *ComponentDTO `json:"payload,omitempty"`
}

// ApiResultResponseListAuthenticationTokenDTO defines model for ApiResultResponseListAuthenticationTokenDTO.
type ApiResultResponseListAuthenticationTokenDTO struct {
	// ErrorCode Is the error code returned from api
	ErrorCode int32 `json:"errorCode"`

	// ErrorDomain In case of error not equal to 0, an error domain can be reported by api, indicating where the problem is occurred
	ErrorDomain *string `json:"errorDomain,omitempty"`

	// ErrorMessage In case of error not equal to 0, an error message can be reported by api, indicating what problem is occurred
	ErrorMessage *string `json:"errorMessage,omitempty"`

	// Payload Is the value returned by api
	Payload *[]AuthenticationTokenDTO `json:"payload,omitempty"`
}

// ApiResultResponseListAuthorizationDTO defines model for ApiResultResponseListAuthorizationDTO.
type ApiResultResponseListAuthorizationDTO struct {
	// ErrorCode Is the error code returned from api
	ErrorCode int32 `json:"errorCode"`

	// ErrorDomain In case of error not equal to 0, an error domain can be reported by api, indicating where the problem is occurred
	ErrorDomain *string `json:"errorDomain,omitempty"`

	// ErrorMessage In case of error not equal to 0, an error message can be reported by api, indicating what problem is occurred
	ErrorMessage *string `json:"errorMessage,omitempty"`

	// Payload Is the value returned by api
	Payload *[]AuthorizationDTO `json:"payload,omitempty"`
}

// ApiResultResponseListCommandTemplateSummaryDTO defines model for ApiResultResponseListCommandTemplateSummaryDTO.
type ApiResultResponseListCommandTemplateSummaryDTO struct {
	// ErrorCode Is the error code returned from api
	ErrorCode int32 `json:"errorCode"`

	// ErrorDomain In case of error not equal to 0, an error domain can be reported by api, indicating where the problem is occurred
	ErrorDomain *string `json:"errorDomain,omitempty"`

	// ErrorMessage In case of error not equal to 0, an error message can be reported by api, indicating what problem is occurred
	ErrorMessage *string `json:"errorMessage,omitempty"`

	// Payload Is the value returned by api
	Payload *[]CommandTemplateSummaryDTO `json:"payload,omitempty"`
}

// ApiResultResponseListComponentSummaryDTO defines model for ApiResultResponseListComponentSummaryDTO.
type ApiResultResponseListComponentSummaryDTO struct {
	// ErrorCode Is the error code returned from api
	ErrorCode int32 `json:"errorCode"`

	// ErrorDomain In case of error not equal to 0, an error domain can be reported by api, indicating where the problem is occurred
	ErrorDomain *string `json:"errorDomain,omitempty"`

	// ErrorMessage In case of error not equal to 0, an error message can be reported by api, indicating what problem is occurred
	ErrorMessage *string `json:"errorMessage,omitempty"`

	// Payload Is the value returned by api
	Payload *[]ComponentSummaryDTO `json:"payload,omitempty"`
}

// ApiResultResponseListGroupDTO defines model for ApiResultResponseListGroupDTO.
type ApiResultResponseListGroupDTO struct {
	// ErrorCode Is the error code returned from api
	ErrorCode int32 `json:"errorCode"`

	// ErrorDomain In case of error not equal to 0, an error domain can be reported by api, indicating where the problem is occurred
	ErrorDomain *string `json:"errorDomain,omitempty"`

	// ErrorMessage In case of error not equal to 0, an error message can be reported by api, indicating what problem is occurred
	ErrorMessage *string `json:"errorMessage,omitempty"`

	// Payload Is the value returned by api
	Payload *[]GroupDTO `json:"payload,omitempty"`
}

// ApiResultResponseListPersonDTO defines model for ApiResultResponseListPersonDTO.
type ApiResultResponseListPersonDTO struct {
	// ErrorCode Is the error code returned from api
	ErrorCode int32 `json:"errorCode"`

	// ErrorDomain In case of error not equal to 0, an error domain can be reported by api, indicating where the problem is occurred
	ErrorDomain *string `json:"errorDomain,omitempty"`

	// ErrorMessage In case of error not equal to 0, an error message can be reported by api, indicating what problem is occurred
	ErrorMessage *string `json:"errorMessage,omitempty"`

	// Payload Is the value returned by api
	Payload *[]PersonDTO `json:"payload,omitempty"`
}

// ApiResultResponseMapStringString defines model for ApiResultResponseMapStringString.
type ApiResultResponseMapStringString struct {
	// ErrorCode Is the error code returned from api
	ErrorCode int32 `json:"errorCode"`

	// ErrorDomain In case of error not equal to 0, an error domain can be reported by api, indicating where the problem is occurred
	ErrorDomain *string `json:"errorDomain,omitempty"`

	// ErrorMessage In case of error not equal to 0, an error message can be reported by api, indicating what problem is occurred
	ErrorMessage *string `json:"errorMessage,omitempty"`

	// Payload Is the value returned by api
	Payload *map[string]string `json:"payload,omitempty"`
}

// ApiResultResponsePersonDTO defines model for ApiResultResponsePersonDTO.
type ApiResultResponsePersonDTO struct {
	// ErrorCode Is the error code returned from api
	ErrorCode int32 `json:"errorCode"`

	// ErrorDomain In case of error not equal to 0, an error domain can be reported by api, indicating where the problem is occurred
	ErrorDomain *string `json:"errorDomain,omitempty"`

	// ErrorMessage In case of error not equal to 0, an error message can be reported by api, indicating what problem is occurred
	ErrorMessage *string `json:"errorMessage,omitempty"`

	// Payload Is the value returned by api
	Payload *PersonDTO `json:"payload,omitempty"`
}

// ApiResultResponseSetString defines model for ApiResultResponseSetString.
type ApiResultResponseSetString struct {
	// ErrorCode Is the error code returned from api
	ErrorCode int32 `json:"errorCode"`

	// ErrorDomain In case of error not equal to 0, an error domain can be reported by api, indicating where the problem is occurred
	ErrorDomain *string `json:"errorDomain,omitempty"`

	// ErrorMessage In case of error not equal to 0, an error message can be reported by api, indicating what problem is occurred
	ErrorMessage *string `json:"errorMessage,omitempty"`

	// Payload Is the value returned by api
	Payload *[]string `json:"payload,omitempty"`
}

// ApiResultResponseString defines model for ApiResultResponseString.
type ApiResultResponseString struct {
	// ErrorCode Is the error code returned from api
	ErrorCode int32 `json:"errorCode"`

	// ErrorDomain In case of error not equal to 0, an error domain can be reported by api, indicating where the problem is occurred
	ErrorDomain *string `json:"errorDomain,omitempty"`

	// ErrorMessage In case of error not equal to 0, an error message can be reported by api, indicating what problem is occurred
	ErrorMessage *string `json:"errorMessage,omitempty"`

	// Payload Is the value returned by api
	Payload *string `json:"payload,omitempty"`
}

// AuthenticationTokenDTO The authentication token
type AuthenticationTokenDTO struct {
	ApplicationManaged *bool               `json:"applicationManaged,omitempty"`
	Email              *string             `json:"email,omitempty"`
	Expiration         *openapi_types.Date `json:"expiration,omitempty"`
	Id                 *string             `json:"id,omitempty"`
	Name               *string             `json:"name,omitempty"`
	Token              *string             `json:"token,omitempty"`
}

// AuthorizationDTO The authorization of the user on the resources returned in the payload
type AuthorizationDTO struct {
	// AuthorizationType Is the type of the authorizations [User, Group, Application]
	AuthorizationType *AuthorizationDTOAuthorizationType `json:"authorizationType,omitempty"`

	// Id Is unique id of the authorizations
	Id *string `json:"id,omitempty"`

	// Owner Is the subject owner of the authorizations
	Owner *string `json:"owner,omitempty"`

	// OwnerType Is the type of the owner [User, Group, Application]
	OwnerType *AuthorizationDTOOwnerType `json:"ownerType,omitempty"`

	// Resource The resource eof the authorizations
	Resource *string `json:"resource,omitempty"`
}

// AuthorizationDTOAuthorizationType Is the type of the authorizations [User, Group, Application]
type AuthorizationDTOAuthorizationType string

// AuthorizationDTOOwnerType Is the type of the owner [User, Group, Application]
type AuthorizationDTOOwnerType string

// CommandTemplateDTO Define details for create a new component
type CommandTemplateDTO struct {
	// CommandExecutionsLayers Those are the list of the action that the command will take
	CommandExecutionsLayers *[]ExecutionPipelineDTO `json:"commandExecutionsLayers,omitempty"`

	// Description The description of the component
	Description *string `json:"description,omitempty"`

	// Id The id of the component
	Id *string `json:"id,omitempty"`

	// Name The name of the component
	Name *string `json:"name,omitempty"`

	// Parameters The parameter used by the command
	Parameters *[]CommandTemplateParameterDTO `json:"parameters,omitempty"`
}

// CommandTemplateInstanceDTO Define an instance of the command template with the parameters values
type CommandTemplateInstanceDTO struct {
	// Id The id of the component
	Id *string `json:"id,omitempty"`

	// Parameters The parameter/values map
	Parameters *map[string]string `json:"parameters,omitempty"`
}

// CommandTemplateParameterDTO Define a single command parameter
type CommandTemplateParameterDTO struct {
	// Description The description of the parameter
	Description string `json:"description"`

	// Name The name of the component
	Name string `json:"name"`
}

// CommandTemplateSummaryDTO Define details for create a new component
type CommandTemplateSummaryDTO struct {
	// CommandExecutionsLayers Those are the list of the action that the command will take
	CommandExecutionsLayers *[]ExecutionPipelineDTO `json:"commandExecutionsLayers,omitempty"`

	// Id The id of the component
	Id *string `json:"id,omitempty"`

	// Name The name of the component
	Name *string `json:"name,omitempty"`

	// Parameters The parameter used by the command
	Parameters *[]CommandTemplateParameterDTO `json:"parameters,omitempty"`
}

// ComponentDTO Define the single component
type ComponentDTO struct {
	// CommandTemplatesInstances The list command template instances to execute to build the component.
	CommandTemplatesInstances *[]CommandTemplateInstanceDTO `json:"commandTemplatesInstances,omitempty"`

	// DependOnComponentIds The list of unique identifier of the components that this component depends on.
	DependOnComponentIds *[]string `json:"dependOnComponentIds,omitempty"`

	// Description The description of the component
	Description *string `json:"description,omitempty"`

	// Id The unique identifier of the component
	Id *string `json:"id,omitempty"`

	// Name The name of the component
	Name *string `json:"name,omitempty"`

	// Url The URL of the component [src, artifact, etc.]
	Url *string `json:"url,omitempty"`
}

// ComponentSummaryDTO Define the single component
type ComponentSummaryDTO struct {
	// Description The description of the component
	Description *string `json:"description,omitempty"`

	// Id The unique identifier of the component
	Id *string `json:"id,omitempty"`

	// Name The name of the component
	Name *string `json:"name,omitempty"`
}

// ExecutionPipelineDTO Define details for create a new execution pipeline for a command
type ExecutionPipelineDTO struct {
	// Architecture The architecture where the pipeline can work
	Architecture *[]string `json:"architecture,omitempty"`

	// Engine The name of the pipeline
	Engine *string `json:"engine,omitempty"`

	// ExecutionCommands The list of the commands that the pipeline will execute
	ExecutionCommands *[]string `json:"executionCommands,omitempty"`

	// OperatingSystem The operating system where the pipeline can work
	OperatingSystem *[]string `json:"operatingSystem,omitempty"`
}

// GroupDTO The group of the user
type GroupDTO struct {
	CommonName *string `json:"commonName,omitempty"`
	Uid        *string `json:"uid,omitempty"`
}

// NewAuthenticationTokenDTO New authentication token for logbook
type NewAuthenticationTokenDTO struct {
	Expiration *openapi_types.Date `json:"expiration,omitempty"`
	Name       *string             `json:"name,omitempty"`
}

// NewCommandTemplateDTO Define details for create a new component
type NewCommandTemplateDTO struct {
	// CommandExecutionsLayers Those are the list of the action that the command will take
	CommandExecutionsLayers []ExecutionPipelineDTO `json:"commandExecutionsLayers"`

	// DependOnComponents The list of the component that this component depend on
	DependOnComponents *[]string `json:"dependOnComponents,omitempty"`

	// Description The description of the component
	Description string `json:"description"`

	// Name The name of the component
	Name string `json:"name"`

	// Parameters The parameter used by the command
	Parameters []CommandTemplateParameterDTO `json:"parameters"`
}

// NewComponentDTO Define details for create a new component
type NewComponentDTO struct {
	// CommandTemplates The list of command templates that the component will use.
	CommandTemplates *[]CommandTemplateDTO `json:"commandTemplates,omitempty"`

	// CommandTemplatesInstances The list command template instances to execute to build the component.
	CommandTemplatesInstances *[]CommandTemplateInstanceDTO `json:"commandTemplatesInstances,omitempty"`

	// DependOnComponentIds The list of unique identifier of the components that this component depends on.
	DependOnComponentIds *[]string `json:"dependOnComponentIds,omitempty"`

	// Description The description of the component
	Description *string `json:"description,omitempty"`

	// Name The name of the component
	Name string `json:"name"`

	// Version The version of the component
	Version *string `json:"version,omitempty"`
}

// PersonDTO Is the value returned by api
type PersonDTO struct {
	CommonName *string `json:"commonName,omitempty"`
	Gecos      *string `json:"gecos,omitempty"`
	Mail       *string `json:"mail,omitempty"`
	Surname    *string `json:"surname,omitempty"`
	Uid        *string `json:"uid,omitempty"`
}

// UpdateCommandTemplateDTO Define details for create a new component
type UpdateCommandTemplateDTO struct {
	// CommandExecutionsLayers Those are the list of the action that the command will take
	CommandExecutionsLayers *[]ExecutionPipelineDTO `json:"commandExecutionsLayers,omitempty"`

	// Description The description of the component
	Description *string `json:"description,omitempty"`

	// Name The name of the component
	Name *string `json:"name,omitempty"`

	// Parameters The parameter used by the command
	Parameters *[]CommandTemplateParameterDTO `json:"parameters,omitempty"`
}

// UpdateComponentDTO Define the single component
type UpdateComponentDTO struct {
	// CommandTemplatesInstances The list command template instances to execute to build the component.
	CommandTemplatesInstances *[]CommandTemplateInstanceDTO `json:"commandTemplatesInstances,omitempty"`

	// DependOnComponentIds The list of unique identifier of the components that this component depends on.
	DependOnComponentIds *[]string `json:"dependOnComponentIds,omitempty"`

	// Description The description of the component
	Description *string `json:"description,omitempty"`

	// Name The name of the component
	Name *string `json:"name,omitempty"`

	// Url The URL of the component [src, artifact, etc.]
	Url *string `json:"url,omitempty"`
}

// FindGroupsParams defines parameters for FindGroups.
type FindGroupsParams struct {
	// Search is the prefix used to filter the groups
	Search *string `form:"search,omitempty" json:"search,omitempty"`
}

// FindPeopleParams defines parameters for FindPeople.
type FindPeopleParams struct {
	// Search is the prefix used to filter the people
	Search *string `form:"search,omitempty" json:"search,omitempty"`
}

// GenerateComponentArtifactParams defines parameters for GenerateComponentArtifact.
type GenerateComponentArtifactParams struct {
	// EngineName IS the engine to use represented by his name
	EngineName string `form:"engineName" json:"engineName"`

	// ComponentId Is the list of the component id for wich the artifact should be generated
	ComponentId []string `form:"componentId" json:"componentId"`

	// AllRequestParams is the build specs to use for the generation of the artifact
	AllRequestParams map[string]string `form:"allRequestParams" json:"allRequestParams"`
}

// CreateNewAuthenticationTokenJSONRequestBody defines body for CreateNewAuthenticationToken for application/json ContentType.
type CreateNewAuthenticationTokenJSONRequestBody = NewAuthenticationTokenDTO

// CreateNewCommandJSONRequestBody defines body for CreateNewCommand for application/json ContentType.
type CreateNewCommandJSONRequestBody = NewCommandTemplateDTO

// UpdateCommandByIdJSONRequestBody defines body for UpdateCommandById for application/json ContentType.
type UpdateCommandByIdJSONRequestBody = UpdateCommandTemplateDTO

// CreateNewComponentJSONRequestBody defines body for CreateNewComponent for application/json ContentType.
type CreateNewComponentJSONRequestBody = NewComponentDTO

// UpdateComponentByIdJSONRequestBody defines body for UpdateComponentById for application/json ContentType.
type UpdateComponentByIdJSONRequestBody = UpdateComponentDTO

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// GetApplicationAuthenticationToken request
	GetApplicationAuthenticationToken(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateNewAuthenticationTokenWithBody request with any body
	CreateNewAuthenticationTokenWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateNewAuthenticationToken(ctx context.Context, body CreateNewAuthenticationTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteAuthenticationToken request
	DeleteAuthenticationToken(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindGroups request
	FindGroups(ctx context.Context, params *FindGroupsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Me request
	Me(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindAllRoot request
	FindAllRoot(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveAsRootUser request
	RemoveAsRootUser(ctx context.Context, email string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetRootUser request
	SetRootUser(ctx context.Context, email string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindPeople request
	FindPeople(ctx context.Context, params *FindPeopleParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListAllCommand request
	ListAllCommand(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateNewCommandWithBody request with any body
	CreateNewCommandWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateNewCommand(ctx context.Context, body CreateNewCommandJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteCommandById request
	DeleteCommandById(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindCommandById request
	FindCommandById(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateCommandByIdWithBody request with any body
	UpdateCommandByIdWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateCommandById(ctx context.Context, id string, body UpdateCommandByIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListAllComponent request
	ListAllComponent(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateNewComponentWithBody request with any body
	CreateNewComponentWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateNewComponent(ctx context.Context, body CreateNewComponentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteComponentById request
	DeleteComponentById(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindComponentById request
	FindComponentById(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateComponentByIdWithBody request with any body
	UpdateComponentByIdWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateComponentById(ctx context.Context, id string, body UpdateComponentByIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteAll request
	DeleteAll(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Echo request
	Echo(ctx context.Context, value string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindAllEngineNames request
	FindAllEngineNames(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GenerateComponentArtifact request
	GenerateComponentArtifact(ctx context.Context, params *GenerateComponentArtifactParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMockUser request
	GetMockUser(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) GetApplicationAuthenticationToken(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetApplicationAuthenticationTokenRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateNewAuthenticationTokenWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateNewAuthenticationTokenRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateNewAuthenticationToken(ctx context.Context, body CreateNewAuthenticationTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateNewAuthenticationTokenRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteAuthenticationToken(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteAuthenticationTokenRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindGroups(ctx context.Context, params *FindGroupsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindGroupsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Me(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMeRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindAllRoot(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindAllRootRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveAsRootUser(ctx context.Context, email string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveAsRootUserRequest(c.Server, email)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetRootUser(ctx context.Context, email string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetRootUserRequest(c.Server, email)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindPeople(ctx context.Context, params *FindPeopleParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindPeopleRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListAllCommand(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListAllCommandRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateNewCommandWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateNewCommandRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateNewCommand(ctx context.Context, body CreateNewCommandJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateNewCommandRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteCommandById(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteCommandByIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindCommandById(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindCommandByIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateCommandByIdWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateCommandByIdRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateCommandById(ctx context.Context, id string, body UpdateCommandByIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateCommandByIdRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListAllComponent(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListAllComponentRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateNewComponentWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateNewComponentRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateNewComponent(ctx context.Context, body CreateNewComponentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateNewComponentRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteComponentById(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteComponentByIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindComponentById(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindComponentByIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateComponentByIdWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateComponentByIdRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateComponentById(ctx context.Context, id string, body UpdateComponentByIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateComponentByIdRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteAll(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteAllRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Echo(ctx context.Context, value string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEchoRequest(c.Server, value)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindAllEngineNames(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindAllEngineNamesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GenerateComponentArtifact(ctx context.Context, params *GenerateComponentArtifactParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGenerateComponentArtifactRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMockUser(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMockUserRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewGetApplicationAuthenticationTokenRequest generates requests for GetApplicationAuthenticationToken
func NewGetApplicationAuthenticationTokenRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/auth/application-token")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateNewAuthenticationTokenRequest calls the generic CreateNewAuthenticationToken builder with application/json body
func NewCreateNewAuthenticationTokenRequest(server string, body CreateNewAuthenticationTokenJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateNewAuthenticationTokenRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateNewAuthenticationTokenRequestWithBody generates requests for CreateNewAuthenticationToken with any type of body
func NewCreateNewAuthenticationTokenRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/auth/application-token")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteAuthenticationTokenRequest generates requests for DeleteAuthenticationToken
func NewDeleteAuthenticationTokenRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/auth/application-token/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindGroupsRequest generates requests for FindGroups
func NewFindGroupsRequest(server string, params *FindGroupsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/auth/groups")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Search != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "search", runtime.ParamLocationQuery, *params.Search); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewMeRequest generates requests for Me
func NewMeRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/auth/me")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindAllRootRequest generates requests for FindAllRoot
func NewFindAllRootRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/auth/root")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRemoveAsRootUserRequest generates requests for RemoveAsRootUser
func NewRemoveAsRootUserRequest(server string, email string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "email", runtime.ParamLocationPath, email)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/auth/root/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetRootUserRequest generates requests for SetRootUser
func NewSetRootUserRequest(server string, email string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "email", runtime.ParamLocationPath, email)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/auth/root/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindPeopleRequest generates requests for FindPeople
func NewFindPeopleRequest(server string, params *FindPeopleParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/auth/users")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Search != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "search", runtime.ParamLocationQuery, *params.Search); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListAllCommandRequest generates requests for ListAllCommand
func NewListAllCommandRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/command")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateNewCommandRequest calls the generic CreateNewCommand builder with application/json body
func NewCreateNewCommandRequest(server string, body CreateNewCommandJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateNewCommandRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateNewCommandRequestWithBody generates requests for CreateNewCommand with any type of body
func NewCreateNewCommandRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/command")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteCommandByIdRequest generates requests for DeleteCommandById
func NewDeleteCommandByIdRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/command/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindCommandByIdRequest generates requests for FindCommandById
func NewFindCommandByIdRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/command/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateCommandByIdRequest calls the generic UpdateCommandById builder with application/json body
func NewUpdateCommandByIdRequest(server string, id string, body UpdateCommandByIdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateCommandByIdRequestWithBody(server, id, "application/json", bodyReader)
}

// NewUpdateCommandByIdRequestWithBody generates requests for UpdateCommandById with any type of body
func NewUpdateCommandByIdRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/command/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListAllComponentRequest generates requests for ListAllComponent
func NewListAllComponentRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/component")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateNewComponentRequest calls the generic CreateNewComponent builder with application/json body
func NewCreateNewComponentRequest(server string, body CreateNewComponentJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateNewComponentRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateNewComponentRequestWithBody generates requests for CreateNewComponent with any type of body
func NewCreateNewComponentRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/component")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteComponentByIdRequest generates requests for DeleteComponentById
func NewDeleteComponentByIdRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/component/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindComponentByIdRequest generates requests for FindComponentById
func NewFindComponentByIdRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/component/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateComponentByIdRequest calls the generic UpdateComponentById builder with application/json body
func NewUpdateComponentByIdRequest(server string, id string, body UpdateComponentByIdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateComponentByIdRequestWithBody(server, id, "application/json", bodyReader)
}

// NewUpdateComponentByIdRequestWithBody generates requests for UpdateComponentById with any type of body
func NewUpdateComponentByIdRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/component/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteAllRequest generates requests for DeleteAll
func NewDeleteAllRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/debug")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewEchoRequest generates requests for Echo
func NewEchoRequest(server string, value string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "value", runtime.ParamLocationPath, value)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/echo/test/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindAllEngineNamesRequest generates requests for FindAllEngineNames
func NewFindAllEngineNamesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/engine/all")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGenerateComponentArtifactRequest generates requests for GenerateComponentArtifact
func NewGenerateComponentArtifactRequest(server string, params *GenerateComponentArtifactParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/engine/generate")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "engineName", runtime.ParamLocationQuery, params.EngineName); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "componentId", runtime.ParamLocationQuery, params.ComponentId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "allRequestParams", runtime.ParamLocationQuery, params.AllRequestParams); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetMockUserRequest generates requests for GetMockUser
func NewGetMockUserRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/mock/users-auth")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// GetApplicationAuthenticationTokenWithResponse request
	GetApplicationAuthenticationTokenWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetApplicationAuthenticationTokenResponse, error)

	// CreateNewAuthenticationTokenWithBodyWithResponse request with any body
	CreateNewAuthenticationTokenWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateNewAuthenticationTokenResponse, error)

	CreateNewAuthenticationTokenWithResponse(ctx context.Context, body CreateNewAuthenticationTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateNewAuthenticationTokenResponse, error)

	// DeleteAuthenticationTokenWithResponse request
	DeleteAuthenticationTokenWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteAuthenticationTokenResponse, error)

	// FindGroupsWithResponse request
	FindGroupsWithResponse(ctx context.Context, params *FindGroupsParams, reqEditors ...RequestEditorFn) (*FindGroupsResponse, error)

	// MeWithResponse request
	MeWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*MeResponse, error)

	// FindAllRootWithResponse request
	FindAllRootWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*FindAllRootResponse, error)

	// RemoveAsRootUserWithResponse request
	RemoveAsRootUserWithResponse(ctx context.Context, email string, reqEditors ...RequestEditorFn) (*RemoveAsRootUserResponse, error)

	// SetRootUserWithResponse request
	SetRootUserWithResponse(ctx context.Context, email string, reqEditors ...RequestEditorFn) (*SetRootUserResponse, error)

	// FindPeopleWithResponse request
	FindPeopleWithResponse(ctx context.Context, params *FindPeopleParams, reqEditors ...RequestEditorFn) (*FindPeopleResponse, error)

	// ListAllCommandWithResponse request
	ListAllCommandWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListAllCommandResponse, error)

	// CreateNewCommandWithBodyWithResponse request with any body
	CreateNewCommandWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateNewCommandResponse, error)

	CreateNewCommandWithResponse(ctx context.Context, body CreateNewCommandJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateNewCommandResponse, error)

	// DeleteCommandByIdWithResponse request
	DeleteCommandByIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteCommandByIdResponse, error)

	// FindCommandByIdWithResponse request
	FindCommandByIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*FindCommandByIdResponse, error)

	// UpdateCommandByIdWithBodyWithResponse request with any body
	UpdateCommandByIdWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateCommandByIdResponse, error)

	UpdateCommandByIdWithResponse(ctx context.Context, id string, body UpdateCommandByIdJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateCommandByIdResponse, error)

	// ListAllComponentWithResponse request
	ListAllComponentWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListAllComponentResponse, error)

	// CreateNewComponentWithBodyWithResponse request with any body
	CreateNewComponentWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateNewComponentResponse, error)

	CreateNewComponentWithResponse(ctx context.Context, body CreateNewComponentJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateNewComponentResponse, error)

	// DeleteComponentByIdWithResponse request
	DeleteComponentByIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteComponentByIdResponse, error)

	// FindComponentByIdWithResponse request
	FindComponentByIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*FindComponentByIdResponse, error)

	// UpdateComponentByIdWithBodyWithResponse request with any body
	UpdateComponentByIdWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateComponentByIdResponse, error)

	UpdateComponentByIdWithResponse(ctx context.Context, id string, body UpdateComponentByIdJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateComponentByIdResponse, error)

	// DeleteAllWithResponse request
	DeleteAllWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*DeleteAllResponse, error)

	// EchoWithResponse request
	EchoWithResponse(ctx context.Context, value string, reqEditors ...RequestEditorFn) (*EchoResponse, error)

	// FindAllEngineNamesWithResponse request
	FindAllEngineNamesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*FindAllEngineNamesResponse, error)

	// GenerateComponentArtifactWithResponse request
	GenerateComponentArtifactWithResponse(ctx context.Context, params *GenerateComponentArtifactParams, reqEditors ...RequestEditorFn) (*GenerateComponentArtifactResponse, error)

	// GetMockUserWithResponse request
	GetMockUserWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetMockUserResponse, error)
}

type GetApplicationAuthenticationTokenResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ApiResultResponseListAuthenticationTokenDTO
}

// Status returns HTTPResponse.Status
func (r GetApplicationAuthenticationTokenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetApplicationAuthenticationTokenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateNewAuthenticationTokenResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *ApiResultResponseAuthenticationTokenDTO
}

// Status returns HTTPResponse.Status
func (r CreateNewAuthenticationTokenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateNewAuthenticationTokenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteAuthenticationTokenResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ApiResultResponseBoolean
}

// Status returns HTTPResponse.Status
func (r DeleteAuthenticationTokenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteAuthenticationTokenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindGroupsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ApiResultResponseListGroupDTO
}

// Status returns HTTPResponse.Status
func (r FindGroupsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindGroupsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ApiResultResponsePersonDTO
}

// Status returns HTTPResponse.Status
func (r MeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindAllRootResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ApiResultResponseListAuthorizationDTO
}

// Status returns HTTPResponse.Status
func (r FindAllRootResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindAllRootResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveAsRootUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ApiResultResponseBoolean
}

// Status returns HTTPResponse.Status
func (r RemoveAsRootUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveAsRootUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetRootUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *ApiResultResponseBoolean
}

// Status returns HTTPResponse.Status
func (r SetRootUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetRootUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindPeopleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ApiResultResponseListPersonDTO
}

// Status returns HTTPResponse.Status
func (r FindPeopleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindPeopleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListAllCommandResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ApiResultResponseListCommandTemplateSummaryDTO
}

// Status returns HTTPResponse.Status
func (r ListAllCommandResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListAllCommandResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateNewCommandResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *ApiResultResponseString
}

// Status returns HTTPResponse.Status
func (r CreateNewCommandResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateNewCommandResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteCommandByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ApiResultResponseBoolean
}

// Status returns HTTPResponse.Status
func (r DeleteCommandByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteCommandByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindCommandByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ApiResultResponseCommandTemplateDTO
}

// Status returns HTTPResponse.Status
func (r FindCommandByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindCommandByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateCommandByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ApiResultResponseBoolean
}

// Status returns HTTPResponse.Status
func (r UpdateCommandByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateCommandByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListAllComponentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ApiResultResponseListComponentSummaryDTO
}

// Status returns HTTPResponse.Status
func (r ListAllComponentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListAllComponentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateNewComponentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *ApiResultResponseString
}

// Status returns HTTPResponse.Status
func (r CreateNewComponentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateNewComponentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteComponentByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ApiResultResponseBoolean
}

// Status returns HTTPResponse.Status
func (r DeleteComponentByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteComponentByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindComponentByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ApiResultResponseComponentDTO
}

// Status returns HTTPResponse.Status
func (r FindComponentByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindComponentByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateComponentByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ApiResultResponseBoolean
}

// Status returns HTTPResponse.Status
func (r UpdateComponentByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateComponentByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteAllResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *ApiResultResponseBoolean
}

// Status returns HTTPResponse.Status
func (r DeleteAllResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteAllResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EchoResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ApiResultResponseString
}

// Status returns HTTPResponse.Status
func (r EchoResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EchoResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindAllEngineNamesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ApiResultResponseSetString
}

// Status returns HTTPResponse.Status
func (r FindAllEngineNamesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindAllEngineNamesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GenerateComponentArtifactResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *openapi_types.File
}

// Status returns HTTPResponse.Status
func (r GenerateComponentArtifactResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GenerateComponentArtifactResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMockUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ApiResultResponseMapStringString
}

// Status returns HTTPResponse.Status
func (r GetMockUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMockUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetApplicationAuthenticationTokenWithResponse request returning *GetApplicationAuthenticationTokenResponse
func (c *ClientWithResponses) GetApplicationAuthenticationTokenWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetApplicationAuthenticationTokenResponse, error) {
	rsp, err := c.GetApplicationAuthenticationToken(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetApplicationAuthenticationTokenResponse(rsp)
}

// CreateNewAuthenticationTokenWithBodyWithResponse request with arbitrary body returning *CreateNewAuthenticationTokenResponse
func (c *ClientWithResponses) CreateNewAuthenticationTokenWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateNewAuthenticationTokenResponse, error) {
	rsp, err := c.CreateNewAuthenticationTokenWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateNewAuthenticationTokenResponse(rsp)
}

func (c *ClientWithResponses) CreateNewAuthenticationTokenWithResponse(ctx context.Context, body CreateNewAuthenticationTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateNewAuthenticationTokenResponse, error) {
	rsp, err := c.CreateNewAuthenticationToken(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateNewAuthenticationTokenResponse(rsp)
}

// DeleteAuthenticationTokenWithResponse request returning *DeleteAuthenticationTokenResponse
func (c *ClientWithResponses) DeleteAuthenticationTokenWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteAuthenticationTokenResponse, error) {
	rsp, err := c.DeleteAuthenticationToken(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteAuthenticationTokenResponse(rsp)
}

// FindGroupsWithResponse request returning *FindGroupsResponse
func (c *ClientWithResponses) FindGroupsWithResponse(ctx context.Context, params *FindGroupsParams, reqEditors ...RequestEditorFn) (*FindGroupsResponse, error) {
	rsp, err := c.FindGroups(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindGroupsResponse(rsp)
}

// MeWithResponse request returning *MeResponse
func (c *ClientWithResponses) MeWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*MeResponse, error) {
	rsp, err := c.Me(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMeResponse(rsp)
}

// FindAllRootWithResponse request returning *FindAllRootResponse
func (c *ClientWithResponses) FindAllRootWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*FindAllRootResponse, error) {
	rsp, err := c.FindAllRoot(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindAllRootResponse(rsp)
}

// RemoveAsRootUserWithResponse request returning *RemoveAsRootUserResponse
func (c *ClientWithResponses) RemoveAsRootUserWithResponse(ctx context.Context, email string, reqEditors ...RequestEditorFn) (*RemoveAsRootUserResponse, error) {
	rsp, err := c.RemoveAsRootUser(ctx, email, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveAsRootUserResponse(rsp)
}

// SetRootUserWithResponse request returning *SetRootUserResponse
func (c *ClientWithResponses) SetRootUserWithResponse(ctx context.Context, email string, reqEditors ...RequestEditorFn) (*SetRootUserResponse, error) {
	rsp, err := c.SetRootUser(ctx, email, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetRootUserResponse(rsp)
}

// FindPeopleWithResponse request returning *FindPeopleResponse
func (c *ClientWithResponses) FindPeopleWithResponse(ctx context.Context, params *FindPeopleParams, reqEditors ...RequestEditorFn) (*FindPeopleResponse, error) {
	rsp, err := c.FindPeople(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindPeopleResponse(rsp)
}

// ListAllCommandWithResponse request returning *ListAllCommandResponse
func (c *ClientWithResponses) ListAllCommandWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListAllCommandResponse, error) {
	rsp, err := c.ListAllCommand(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListAllCommandResponse(rsp)
}

// CreateNewCommandWithBodyWithResponse request with arbitrary body returning *CreateNewCommandResponse
func (c *ClientWithResponses) CreateNewCommandWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateNewCommandResponse, error) {
	rsp, err := c.CreateNewCommandWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateNewCommandResponse(rsp)
}

func (c *ClientWithResponses) CreateNewCommandWithResponse(ctx context.Context, body CreateNewCommandJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateNewCommandResponse, error) {
	rsp, err := c.CreateNewCommand(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateNewCommandResponse(rsp)
}

// DeleteCommandByIdWithResponse request returning *DeleteCommandByIdResponse
func (c *ClientWithResponses) DeleteCommandByIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteCommandByIdResponse, error) {
	rsp, err := c.DeleteCommandById(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteCommandByIdResponse(rsp)
}

// FindCommandByIdWithResponse request returning *FindCommandByIdResponse
func (c *ClientWithResponses) FindCommandByIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*FindCommandByIdResponse, error) {
	rsp, err := c.FindCommandById(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindCommandByIdResponse(rsp)
}

// UpdateCommandByIdWithBodyWithResponse request with arbitrary body returning *UpdateCommandByIdResponse
func (c *ClientWithResponses) UpdateCommandByIdWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateCommandByIdResponse, error) {
	rsp, err := c.UpdateCommandByIdWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateCommandByIdResponse(rsp)
}

func (c *ClientWithResponses) UpdateCommandByIdWithResponse(ctx context.Context, id string, body UpdateCommandByIdJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateCommandByIdResponse, error) {
	rsp, err := c.UpdateCommandById(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateCommandByIdResponse(rsp)
}

// ListAllComponentWithResponse request returning *ListAllComponentResponse
func (c *ClientWithResponses) ListAllComponentWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListAllComponentResponse, error) {
	rsp, err := c.ListAllComponent(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListAllComponentResponse(rsp)
}

// CreateNewComponentWithBodyWithResponse request with arbitrary body returning *CreateNewComponentResponse
func (c *ClientWithResponses) CreateNewComponentWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateNewComponentResponse, error) {
	rsp, err := c.CreateNewComponentWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateNewComponentResponse(rsp)
}

func (c *ClientWithResponses) CreateNewComponentWithResponse(ctx context.Context, body CreateNewComponentJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateNewComponentResponse, error) {
	rsp, err := c.CreateNewComponent(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateNewComponentResponse(rsp)
}

// DeleteComponentByIdWithResponse request returning *DeleteComponentByIdResponse
func (c *ClientWithResponses) DeleteComponentByIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteComponentByIdResponse, error) {
	rsp, err := c.DeleteComponentById(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteComponentByIdResponse(rsp)
}

// FindComponentByIdWithResponse request returning *FindComponentByIdResponse
func (c *ClientWithResponses) FindComponentByIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*FindComponentByIdResponse, error) {
	rsp, err := c.FindComponentById(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindComponentByIdResponse(rsp)
}

// UpdateComponentByIdWithBodyWithResponse request with arbitrary body returning *UpdateComponentByIdResponse
func (c *ClientWithResponses) UpdateComponentByIdWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateComponentByIdResponse, error) {
	rsp, err := c.UpdateComponentByIdWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateComponentByIdResponse(rsp)
}

func (c *ClientWithResponses) UpdateComponentByIdWithResponse(ctx context.Context, id string, body UpdateComponentByIdJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateComponentByIdResponse, error) {
	rsp, err := c.UpdateComponentById(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateComponentByIdResponse(rsp)
}

// DeleteAllWithResponse request returning *DeleteAllResponse
func (c *ClientWithResponses) DeleteAllWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*DeleteAllResponse, error) {
	rsp, err := c.DeleteAll(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteAllResponse(rsp)
}

// EchoWithResponse request returning *EchoResponse
func (c *ClientWithResponses) EchoWithResponse(ctx context.Context, value string, reqEditors ...RequestEditorFn) (*EchoResponse, error) {
	rsp, err := c.Echo(ctx, value, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEchoResponse(rsp)
}

// FindAllEngineNamesWithResponse request returning *FindAllEngineNamesResponse
func (c *ClientWithResponses) FindAllEngineNamesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*FindAllEngineNamesResponse, error) {
	rsp, err := c.FindAllEngineNames(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindAllEngineNamesResponse(rsp)
}

// GenerateComponentArtifactWithResponse request returning *GenerateComponentArtifactResponse
func (c *ClientWithResponses) GenerateComponentArtifactWithResponse(ctx context.Context, params *GenerateComponentArtifactParams, reqEditors ...RequestEditorFn) (*GenerateComponentArtifactResponse, error) {
	rsp, err := c.GenerateComponentArtifact(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGenerateComponentArtifactResponse(rsp)
}

// GetMockUserWithResponse request returning *GetMockUserResponse
func (c *ClientWithResponses) GetMockUserWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetMockUserResponse, error) {
	rsp, err := c.GetMockUser(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMockUserResponse(rsp)
}

// ParseGetApplicationAuthenticationTokenResponse parses an HTTP response from a GetApplicationAuthenticationTokenWithResponse call
func ParseGetApplicationAuthenticationTokenResponse(rsp *http.Response) (*GetApplicationAuthenticationTokenResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetApplicationAuthenticationTokenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ApiResultResponseListAuthenticationTokenDTO
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateNewAuthenticationTokenResponse parses an HTTP response from a CreateNewAuthenticationTokenWithResponse call
func ParseCreateNewAuthenticationTokenResponse(rsp *http.Response) (*CreateNewAuthenticationTokenResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateNewAuthenticationTokenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest ApiResultResponseAuthenticationTokenDTO
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseDeleteAuthenticationTokenResponse parses an HTTP response from a DeleteAuthenticationTokenWithResponse call
func ParseDeleteAuthenticationTokenResponse(rsp *http.Response) (*DeleteAuthenticationTokenResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteAuthenticationTokenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ApiResultResponseBoolean
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseFindGroupsResponse parses an HTTP response from a FindGroupsWithResponse call
func ParseFindGroupsResponse(rsp *http.Response) (*FindGroupsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindGroupsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ApiResultResponseListGroupDTO
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseMeResponse parses an HTTP response from a MeWithResponse call
func ParseMeResponse(rsp *http.Response) (*MeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ApiResultResponsePersonDTO
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseFindAllRootResponse parses an HTTP response from a FindAllRootWithResponse call
func ParseFindAllRootResponse(rsp *http.Response) (*FindAllRootResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindAllRootResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ApiResultResponseListAuthorizationDTO
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseRemoveAsRootUserResponse parses an HTTP response from a RemoveAsRootUserWithResponse call
func ParseRemoveAsRootUserResponse(rsp *http.Response) (*RemoveAsRootUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemoveAsRootUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ApiResultResponseBoolean
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseSetRootUserResponse parses an HTTP response from a SetRootUserWithResponse call
func ParseSetRootUserResponse(rsp *http.Response) (*SetRootUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetRootUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest ApiResultResponseBoolean
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseFindPeopleResponse parses an HTTP response from a FindPeopleWithResponse call
func ParseFindPeopleResponse(rsp *http.Response) (*FindPeopleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindPeopleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ApiResultResponseListPersonDTO
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListAllCommandResponse parses an HTTP response from a ListAllCommandWithResponse call
func ParseListAllCommandResponse(rsp *http.Response) (*ListAllCommandResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListAllCommandResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ApiResultResponseListCommandTemplateSummaryDTO
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateNewCommandResponse parses an HTTP response from a CreateNewCommandWithResponse call
func ParseCreateNewCommandResponse(rsp *http.Response) (*CreateNewCommandResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateNewCommandResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest ApiResultResponseString
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseDeleteCommandByIdResponse parses an HTTP response from a DeleteCommandByIdWithResponse call
func ParseDeleteCommandByIdResponse(rsp *http.Response) (*DeleteCommandByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteCommandByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ApiResultResponseBoolean
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseFindCommandByIdResponse parses an HTTP response from a FindCommandByIdWithResponse call
func ParseFindCommandByIdResponse(rsp *http.Response) (*FindCommandByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindCommandByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ApiResultResponseCommandTemplateDTO
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateCommandByIdResponse parses an HTTP response from a UpdateCommandByIdWithResponse call
func ParseUpdateCommandByIdResponse(rsp *http.Response) (*UpdateCommandByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateCommandByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ApiResultResponseBoolean
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListAllComponentResponse parses an HTTP response from a ListAllComponentWithResponse call
func ParseListAllComponentResponse(rsp *http.Response) (*ListAllComponentResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListAllComponentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ApiResultResponseListComponentSummaryDTO
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateNewComponentResponse parses an HTTP response from a CreateNewComponentWithResponse call
func ParseCreateNewComponentResponse(rsp *http.Response) (*CreateNewComponentResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateNewComponentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest ApiResultResponseString
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseDeleteComponentByIdResponse parses an HTTP response from a DeleteComponentByIdWithResponse call
func ParseDeleteComponentByIdResponse(rsp *http.Response) (*DeleteComponentByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteComponentByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ApiResultResponseBoolean
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseFindComponentByIdResponse parses an HTTP response from a FindComponentByIdWithResponse call
func ParseFindComponentByIdResponse(rsp *http.Response) (*FindComponentByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindComponentByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ApiResultResponseComponentDTO
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateComponentByIdResponse parses an HTTP response from a UpdateComponentByIdWithResponse call
func ParseUpdateComponentByIdResponse(rsp *http.Response) (*UpdateComponentByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateComponentByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ApiResultResponseBoolean
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteAllResponse parses an HTTP response from a DeleteAllWithResponse call
func ParseDeleteAllResponse(rsp *http.Response) (*DeleteAllResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteAllResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest ApiResultResponseBoolean
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseEchoResponse parses an HTTP response from a EchoWithResponse call
func ParseEchoResponse(rsp *http.Response) (*EchoResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EchoResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ApiResultResponseString
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseFindAllEngineNamesResponse parses an HTTP response from a FindAllEngineNamesWithResponse call
func ParseFindAllEngineNamesResponse(rsp *http.Response) (*FindAllEngineNamesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindAllEngineNamesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ApiResultResponseSetString
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGenerateComponentArtifactResponse parses an HTTP response from a GenerateComponentArtifactWithResponse call
func ParseGenerateComponentArtifactResponse(rsp *http.Response) (*GenerateComponentArtifactResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GenerateComponentArtifactResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest openapi_types.File
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetMockUserResponse parses an HTTP response from a GetMockUserWithResponse call
func ParseGetMockUserResponse(rsp *http.Response) (*GetMockUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMockUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ApiResultResponseMapStringString
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ServerInterface represents all server handlers.
type ServerInterface interface {

	// (GET /v1/auth/application-token)
	GetApplicationAuthenticationToken(ctx echo.Context) error

	// (POST /v1/auth/application-token)
	CreateNewAuthenticationToken(ctx echo.Context) error

	// (DELETE /v1/auth/application-token/{id})
	DeleteAuthenticationToken(ctx echo.Context, id string) error

	// (GET /v1/auth/groups)
	FindGroups(ctx echo.Context, params FindGroupsParams) error

	// (GET /v1/auth/me)
	Me(ctx echo.Context) error

	// (GET /v1/auth/root)
	FindAllRoot(ctx echo.Context) error

	// (DELETE /v1/auth/root/{email})
	RemoveAsRootUser(ctx echo.Context, email string) error

	// (POST /v1/auth/root/{email})
	SetRootUser(ctx echo.Context, email string) error

	// (GET /v1/auth/users)
	FindPeople(ctx echo.Context, params FindPeopleParams) error
	// List all command templates
	// (GET /v1/command)
	ListAllCommand(ctx echo.Context) error
	// Create a new component
	// (POST /v1/command)
	CreateNewCommand(ctx echo.Context) error
	// Return a command template by its unique identifier
	// (DELETE /v1/command/{id})
	DeleteCommandById(ctx echo.Context, id string) error
	// List all command templates
	// (GET /v1/command/{id})
	FindCommandById(ctx echo.Context, id string) error
	// Update a command template by its unique identifier
	// (PUT /v1/command/{id})
	UpdateCommandById(ctx echo.Context, id string) error
	// List all components
	// (GET /v1/component)
	ListAllComponent(ctx echo.Context) error
	// Create a new component
	// (POST /v1/component)
	CreateNewComponent(ctx echo.Context) error
	// Delete a component by his id
	// (DELETE /v1/component/{id})
	DeleteComponentById(ctx echo.Context, id string) error
	// Find a component by an id
	// (GET /v1/component/{id})
	FindComponentById(ctx echo.Context, id string) error
	// Delete a component by his id
	// (PUT /v1/component/{id})
	UpdateComponentById(ctx echo.Context, id string) error
	// Reset all the data
	// (POST /v1/debug)
	DeleteAll(ctx echo.Context) error
	// Example api that realize an ECHO
	// (GET /v1/echo/test/{value})
	Echo(ctx echo.Context, value string) error
	// Return all engine name
	// (GET /v1/engine/all)
	FindAllEngineNames(ctx echo.Context) error
	// Generate component artifact using a specific engine
	// (GET /v1/engine/generate)
	GenerateComponentArtifact(ctx echo.Context, params GenerateComponentArtifactParams) error

	// (GET /v1/mock/users-auth)
	GetMockUser(ctx echo.Context) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// GetApplicationAuthenticationToken converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationAuthenticationToken(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetApplicationAuthenticationToken(ctx)
	return err
}

// CreateNewAuthenticationToken converts echo context to params.
func (w *ServerInterfaceWrapper) CreateNewAuthenticationToken(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.CreateNewAuthenticationToken(ctx)
	return err
}

// DeleteAuthenticationToken converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteAuthenticationToken(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteAuthenticationToken(ctx, id)
	return err
}

// FindGroups converts echo context to params.
func (w *ServerInterfaceWrapper) FindGroups(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params FindGroupsParams
	// ------------- Optional query parameter "search" -------------

	err = runtime.BindQueryParameter("form", true, false, "search", ctx.QueryParams(), &params.Search)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter search: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.FindGroups(ctx, params)
	return err
}

// Me converts echo context to params.
func (w *ServerInterfaceWrapper) Me(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.Me(ctx)
	return err
}

// FindAllRoot converts echo context to params.
func (w *ServerInterfaceWrapper) FindAllRoot(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.FindAllRoot(ctx)
	return err
}

// RemoveAsRootUser converts echo context to params.
func (w *ServerInterfaceWrapper) RemoveAsRootUser(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "email" -------------
	var email string

	err = runtime.BindStyledParameterWithOptions("simple", "email", ctx.Param("email"), &email, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter email: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.RemoveAsRootUser(ctx, email)
	return err
}

// SetRootUser converts echo context to params.
func (w *ServerInterfaceWrapper) SetRootUser(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "email" -------------
	var email string

	err = runtime.BindStyledParameterWithOptions("simple", "email", ctx.Param("email"), &email, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter email: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.SetRootUser(ctx, email)
	return err
}

// FindPeople converts echo context to params.
func (w *ServerInterfaceWrapper) FindPeople(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params FindPeopleParams
	// ------------- Optional query parameter "search" -------------

	err = runtime.BindQueryParameter("form", true, false, "search", ctx.QueryParams(), &params.Search)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter search: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.FindPeople(ctx, params)
	return err
}

// ListAllCommand converts echo context to params.
func (w *ServerInterfaceWrapper) ListAllCommand(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ListAllCommand(ctx)
	return err
}

// CreateNewCommand converts echo context to params.
func (w *ServerInterfaceWrapper) CreateNewCommand(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.CreateNewCommand(ctx)
	return err
}

// DeleteCommandById converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteCommandById(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteCommandById(ctx, id)
	return err
}

// FindCommandById converts echo context to params.
func (w *ServerInterfaceWrapper) FindCommandById(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.FindCommandById(ctx, id)
	return err
}

// UpdateCommandById converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateCommandById(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.UpdateCommandById(ctx, id)
	return err
}

// ListAllComponent converts echo context to params.
func (w *ServerInterfaceWrapper) ListAllComponent(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ListAllComponent(ctx)
	return err
}

// CreateNewComponent converts echo context to params.
func (w *ServerInterfaceWrapper) CreateNewComponent(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.CreateNewComponent(ctx)
	return err
}

// DeleteComponentById converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteComponentById(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteComponentById(ctx, id)
	return err
}

// FindComponentById converts echo context to params.
func (w *ServerInterfaceWrapper) FindComponentById(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.FindComponentById(ctx, id)
	return err
}

// UpdateComponentById converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateComponentById(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.UpdateComponentById(ctx, id)
	return err
}

// DeleteAll converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteAll(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteAll(ctx)
	return err
}

// Echo converts echo context to params.
func (w *ServerInterfaceWrapper) Echo(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "value" -------------
	var value string

	err = runtime.BindStyledParameterWithOptions("simple", "value", ctx.Param("value"), &value, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter value: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.Echo(ctx, value)
	return err
}

// FindAllEngineNames converts echo context to params.
func (w *ServerInterfaceWrapper) FindAllEngineNames(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.FindAllEngineNames(ctx)
	return err
}

// GenerateComponentArtifact converts echo context to params.
func (w *ServerInterfaceWrapper) GenerateComponentArtifact(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GenerateComponentArtifactParams
	// ------------- Required query parameter "engineName" -------------

	err = runtime.BindQueryParameter("form", true, true, "engineName", ctx.QueryParams(), &params.EngineName)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter engineName: %s", err))
	}

	// ------------- Required query parameter "componentId" -------------

	err = runtime.BindQueryParameter("form", true, true, "componentId", ctx.QueryParams(), &params.ComponentId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter componentId: %s", err))
	}

	// ------------- Required query parameter "allRequestParams" -------------

	err = runtime.BindQueryParameter("form", true, true, "allRequestParams", ctx.QueryParams(), &params.AllRequestParams)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter allRequestParams: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GenerateComponentArtifact(ctx, params)
	return err
}

// GetMockUser converts echo context to params.
func (w *ServerInterfaceWrapper) GetMockUser(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetMockUser(ctx)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {
	RegisterHandlersWithBaseURL(router, si, "")
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/v1/auth/application-token", wrapper.GetApplicationAuthenticationToken)
	router.POST(baseURL+"/v1/auth/application-token", wrapper.CreateNewAuthenticationToken)
	router.DELETE(baseURL+"/v1/auth/application-token/:id", wrapper.DeleteAuthenticationToken)
	router.GET(baseURL+"/v1/auth/groups", wrapper.FindGroups)
	router.GET(baseURL+"/v1/auth/me", wrapper.Me)
	router.GET(baseURL+"/v1/auth/root", wrapper.FindAllRoot)
	router.DELETE(baseURL+"/v1/auth/root/:email", wrapper.RemoveAsRootUser)
	router.POST(baseURL+"/v1/auth/root/:email", wrapper.SetRootUser)
	router.GET(baseURL+"/v1/auth/users", wrapper.FindPeople)
	router.GET(baseURL+"/v1/command", wrapper.ListAllCommand)
	router.POST(baseURL+"/v1/command", wrapper.CreateNewCommand)
	router.DELETE(baseURL+"/v1/command/:id", wrapper.DeleteCommandById)
	router.GET(baseURL+"/v1/command/:id", wrapper.FindCommandById)
	router.PUT(baseURL+"/v1/command/:id", wrapper.UpdateCommandById)
	router.GET(baseURL+"/v1/component", wrapper.ListAllComponent)
	router.POST(baseURL+"/v1/component", wrapper.CreateNewComponent)
	router.DELETE(baseURL+"/v1/component/:id", wrapper.DeleteComponentById)
	router.GET(baseURL+"/v1/component/:id", wrapper.FindComponentById)
	router.PUT(baseURL+"/v1/component/:id", wrapper.UpdateComponentById)
	router.POST(baseURL+"/v1/debug", wrapper.DeleteAll)
	router.GET(baseURL+"/v1/echo/test/:value", wrapper.Echo)
	router.GET(baseURL+"/v1/engine/all", wrapper.FindAllEngineNames)
	router.GET(baseURL+"/v1/engine/generate", wrapper.GenerateComponentArtifact)
	router.GET(baseURL+"/v1/mock/users-auth", wrapper.GetMockUser)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"H4sIAAAAAAAC/+xc23LbONJ+FRT//2qHtpyZm1lfrXzYrGtycFlJpWpTvoDAloQxCDAAaEdx6d23cOBJ",
	"AiXKkpXE4c1MLEIN4OuvD2i0+BgRkWaCA9cqOn2MFJlBiu0/hxm9AZUzfQMqE1zBMNcz4JoSrKngH8Qd",
	"8IsP783QTIoMpKZgvwhSCnkuEjB/JKCIpJn5RnQaXSmkZ4DsCEREAkiCziWHBE2kSBHOaBRHEyFTrKPT",
	"iHL9x+9RHOl5Bu5PmIKMFrGb40KkmPLALBwRrACJiZ+JC43gS44Z0gKdxAhz/yCxEhDBHI3NWjIhNSRo",
	"PDcriRHlid0tn6KHGUiwi8+kGDNIEVVIEJJLCUm1RKUl5dNyhW9BKTyFXZaYOhHd1oh11+VleM4ETszK",
	"/l/CJDqN/m9QUWHgeTBo0fliEUcSvuTUSD/9XFP5bTmXGP8NRJu5Vph0JgQDzHvq/OzUCaroHrO8ph03",
	"WyVo7JW/I4fORZpinnyANGNYQ++JXrgnCuh7dwa5SXruvHzuVJrekTVvqNJ9JtSHs4hqSNVT86dyHVhK",
	"PN8XJ4Wk3+xEPRt7NrawscGRZ+DhUpwe5WmK5bwnZE/IzUldjSzPw0w3f8/JnpMdksXnZeNrKfKsp2BP",
	"wQAFS248A++uQao+QeyJFyReRY49M+8tzkZ2C+6/Pfd+du7hJKFmWZhdN/T4lIpwNcFTvl2wbjeC9m7x",
	"l6gE1hzcbnwZge5d2a8cRndzdI3YGkc5p19yuHKytcxhV3b21Pxl71cLQdsxqPVGo7mEDzNAuDEWaTM4",
	"ipeYhrOM+RFvMcdTsPtZvgKOI0gxZbVHNS19zajEbt7HingJ1hBCjSZBKRynEHzglr36ZNGCznJtPYxL",
	"OcrQxygrVyCRQWlmVKZELgmoSnnUPSlUvoJiXeQHu6wWUpg1F3M2vqXQ548KZIzsoTJGw0oxt1EcAc9T",
	"Q48bsNN/ktTCO0xSymtMWcZ5ZQ3OgyGahBcR0ph44CBbN6RyCz+yo7YU2hkpJ7wTQGZMFEd2UBRH1kSC",
	"ABVaDpOkeIqg45ZCfAz3PjQnu4AJ5YAS0JgyhSbGq0vAGhBGHB5QmRytkI446ZdfgeR2UW/wHKQK7Uco",
	"QNg7X0aVLvVEnGswXs/87UWiB8oY0vgOuh5Iy0Vc0wwY5RA6m4bi59JZIqSK2ifFuuugdGK+kVNxfu3X",
	"C0+0KsA86SQiwxKnoFuUYdyIf27cjo0MNfCfWJO/LmR2Rb4DYa+40piTtcTFHFE/rIaNZZH2YtAD1TPv",
	"PwtgXHRUK6TeUXlN5LsdfhsaGbh1oRRnmw++m79ZO/RuAruhwFa0kaJ8yiqMy+lXkHyKXdWl7d8wljKd",
	"uhwv/XYzTM1Lod6XNnxp7/p2cX2NLrMgs2zCUxrgei4Vq1OFF21BxHJoxWUWPlWZwwxYRoD55zinLGmq",
	"4fiJsNW9e9dQnQFP3vMSq6tk3abEpEo3zUFkQqsMsVpeYTFUVR8iN5NCgh+3H+b3P9H25/8D5i+bt/hM",
	"Np1LFpbw8ebNigD0WUkSIyw1nWCiYwSaHN92zpdDN/9PN8WXrpsQiMHwsXWohEIKyrwYOwbXXPXSEViS",
	"GdVAdC5b9lQfUS8GFfIJ5uhByLv1Br+FlPXWvDBnxinlHTRQCA8WqQqgvHfd4Kdq0U5VuUK5epsseHff",
	"zfFtJ3AjJEalthQ2misNaXjuchBSdtTTtbmlpA3LD5lDvX9jdf6peVqvAQWjueDv2spTebCeFVrIO3jo",
	"Wr17Bw/B6p01QSamYyHuVha6ZR2upeDWsvK+kvGU9Kib6fq42Z6dIHtA6u4LOgr8IZKdX+jIUT/7tjE+",
	"Dp2KG1u8bTXQzceXp5tmeZhZT8DlY4xqGKTnoDXJXMFTzy3Btpf4RRy7+jPWz+N27kGq1vX4h9sXxVrL",
	"YI3Gl63uG7fKZ6ZAhAo+ab0AVLnku6dHHzOTqfR5Rh+ED1v3K3nXV//66t/LiEwHqtcZ1w8kl1TPR4Zj",
	"juJngCVIZI669j7PzD0DnNijtdtc9PXoXuRkdkST7AgTAkoVzSkF4hn9C8yBfhFHlE+EMyyuMdH2qOti",
	"UTSmCqac/kthcmzYPBEyOYYkr2YaXl+hUZ5lQhqkLDDRTOtMnQ4GRPAJy4ETOFZsScIgoSpjeD64vLz4",
	"NLww//vtE4x/qzUdqNX7wHMhAZ1ZG3XlE2TmNwHKQD4kBBhIrIVEF/Se2gQBazR6MzxH77C7qGyMeoPH",
	"wv7LsE9TzaBtkqiWj0S+jsNN+D+N/jg+OX5lzxB6ZjU0uH81wLmeDWq9P0dlm80ULMS+MCP4VRKdRq9B",
	"13YeKGNEtp/C9rTZOX4/OSl0ZkjabDQa/K2ctTjXtPHXkFv8tNsypqmU93858uKpMglWo4/jyCxQCsZA",
	"RrcmigkV2P25zS7C9ZvIpW+g9JlI5nvbc3uxaNHMGL0bWgL/1fOB3x14B1vSFf1FvIaZg0eaLJxTY6Bh",
	"VUcX9vOwguq5yeeW5NlHEGg2RgXa56xDM7ZUORmaRMsqiWvwLjvS20Payln5FpcdDKOuGlsxVa2e4t+U",
	"J6/dkA3AU+V7QWFCv7qsUAs0ocwkibqozaoC8i85WDfoMVeAJTE6+EFwbvxUcG9gu1QgCPRbOKjPrTfk",
	"72lzUgi9lkdDxm7MmO8RW5o/v9/nlgePNn1Z681uIBX3MFRm+76hccmWAm7IZUUv2xO1hegR6INj9eq7",
	"YLVDVM2VP563Wtw1iIzBzp47K8T8LJ57v96tqGq0IW19DGPnZfHjsJtd8zKH1s0rN8gvHmHGVmv9UYWR",
	"f7Zlel0H5FlS6uC7yb5vOj0qOL/W0Cv4z9sqnWuhbxKzYzLt0TqbXyWdfOrPnQZXEN/YCnrV6lKV5cZz",
	"RLVarTZtZn6rx31JILeZ13N6lDyAa+Mq4VmR3b+Xar0G6eSofhALcpvYpwVVDsw7vM2xtfSMB4+uq6+l",
	"2dIKiu6RBijuw+1Dag2H5wqq9Zc2vrxwGgJ+mY/dQ6ob/8sFVbd/5xL8xcN4jmZUIbvDjTxfF0BfEKSr",
	"xrQBVwPBMqqYdwR1ffQ8AKzPGD+39Ekvwky8V0pgnLuXCgSDgy+VMxb9gCWNehquwEVEPQOUYI1rANgt",
	"TkEe5ZoyqudBHIDMxECD0oNH2xuzaM0aLslMdLwocF029jLZ9nyMofErcQM5KoWH7wusiLXGspeZM6w1",
	"SCPgMz76Njz678nRP2//EbjZPaiHa4/QK8Zw+RWnGQOEM+q2LQEz+s3+5vTy/D/va3wwCkTnJQfQ/asa",
	"DWyX/wAztqnafGlHvsOpPXocEJPyJTXbnE8ZQ25ryHeJFmC4T8Mm4bCYAjfbhzUXvm5A6UiHvj9go5WM",
	"3OtJ3MK0QLmyb9yQoID7l24Yd+aXHCoQQqmFrQJK3GI24eZomth7+QdK3C+Ti/4HpGYiZ4kxrgKkpGWd",
	"pOqDWbvQsn9l468XWgqtrutHZUBUgWjRU+DXWGsuwZWiwNmPmdqKGBkJpf9ZhHeFGbtxcdm2V6m1W2v7",
	"gXXbTsvWkV1dTvnzhjHl2LVHLNFhsx0VHK+xomRBriifImxBpxNKPKG7GVkqyJ0rth9h3wbT1lXxVpA7",
	"f2lxOHez/JK/zTVvs6Mjs6Ol/doWIHkfdgUFvglyY1AuWaMJ53QwIGN1+ufJnyeRYYSfbVnOCOQ9JYBM",
	"JLdasV2tnq4Bx7+4XfwvAAD//4mLtn8vaQAA",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
