// Package cbs provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen/v2 version v2.1.0 DO NOT EDIT.
package cbs

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

// Defines values for AuthorizationDTOAuthorizationType.
const (
	Admin AuthorizationDTOAuthorizationType = "Admin"
	Read  AuthorizationDTOAuthorizationType = "Read"
	Write AuthorizationDTOAuthorizationType = "Write"
)

// Defines values for AuthorizationDTOOwnerType.
const (
	Group AuthorizationDTOOwnerType = "Group"
	Token AuthorizationDTOOwnerType = "Token"
	User  AuthorizationDTOOwnerType = "User"
)

// ApiResultResponseAuthenticationTokenDTO defines model for ApiResultResponseAuthenticationTokenDTO.
type ApiResultResponseAuthenticationTokenDTO struct {
	// ErrorCode Is the error code returned from api
	ErrorCode int32 `json:"errorCode"`

	// ErrorDomain In case of error not equal to 0, an error domain can be reported by api, indicating where the problem is occurred
	ErrorDomain *string `json:"errorDomain,omitempty"`

	// ErrorMessage In case of error not equal to 0, an error message can be reported by api, indicating what problem is occurred
	ErrorMessage *string `json:"errorMessage,omitempty"`

	// Payload The authentication token
	Payload *AuthenticationTokenDTO `json:"payload,omitempty"`
}

// ApiResultResponseBoolean defines model for ApiResultResponseBoolean.
type ApiResultResponseBoolean struct {
	// ErrorCode Is the error code returned from api
	ErrorCode int32 `json:"errorCode"`

	// ErrorDomain In case of error not equal to 0, an error domain can be reported by api, indicating where the problem is occurred
	ErrorDomain *string `json:"errorDomain,omitempty"`

	// ErrorMessage In case of error not equal to 0, an error message can be reported by api, indicating what problem is occurred
	ErrorMessage *string `json:"errorMessage,omitempty"`

	// Payload Is the value returned by api
	Payload *bool `json:"payload,omitempty"`
}

// ApiResultResponseListAuthenticationTokenDTO defines model for ApiResultResponseListAuthenticationTokenDTO.
type ApiResultResponseListAuthenticationTokenDTO struct {
	// ErrorCode Is the error code returned from api
	ErrorCode int32 `json:"errorCode"`

	// ErrorDomain In case of error not equal to 0, an error domain can be reported by api, indicating where the problem is occurred
	ErrorDomain *string `json:"errorDomain,omitempty"`

	// ErrorMessage In case of error not equal to 0, an error message can be reported by api, indicating what problem is occurred
	ErrorMessage *string `json:"errorMessage,omitempty"`

	// Payload Is the value returned by api
	Payload *[]AuthenticationTokenDTO `json:"payload,omitempty"`
}

// ApiResultResponseListAuthorizationDTO defines model for ApiResultResponseListAuthorizationDTO.
type ApiResultResponseListAuthorizationDTO struct {
	// ErrorCode Is the error code returned from api
	ErrorCode int32 `json:"errorCode"`

	// ErrorDomain In case of error not equal to 0, an error domain can be reported by api, indicating where the problem is occurred
	ErrorDomain *string `json:"errorDomain,omitempty"`

	// ErrorMessage In case of error not equal to 0, an error message can be reported by api, indicating what problem is occurred
	ErrorMessage *string `json:"errorMessage,omitempty"`

	// Payload Is the value returned by api
	Payload *[]AuthorizationDTO `json:"payload,omitempty"`
}

// ApiResultResponseListComponentDTO defines model for ApiResultResponseListComponentDTO.
type ApiResultResponseListComponentDTO struct {
	// ErrorCode Is the error code returned from api
	ErrorCode int32 `json:"errorCode"`

	// ErrorDomain In case of error not equal to 0, an error domain can be reported by api, indicating where the problem is occurred
	ErrorDomain *string `json:"errorDomain,omitempty"`

	// ErrorMessage In case of error not equal to 0, an error message can be reported by api, indicating what problem is occurred
	ErrorMessage *string `json:"errorMessage,omitempty"`

	// Payload Is the value returned by api
	Payload *[]ComponentDTO `json:"payload,omitempty"`
}

// ApiResultResponseListGroupDTO defines model for ApiResultResponseListGroupDTO.
type ApiResultResponseListGroupDTO struct {
	// ErrorCode Is the error code returned from api
	ErrorCode int32 `json:"errorCode"`

	// ErrorDomain In case of error not equal to 0, an error domain can be reported by api, indicating where the problem is occurred
	ErrorDomain *string `json:"errorDomain,omitempty"`

	// ErrorMessage In case of error not equal to 0, an error message can be reported by api, indicating what problem is occurred
	ErrorMessage *string `json:"errorMessage,omitempty"`

	// Payload Is the value returned by api
	Payload *[]GroupDTO `json:"payload,omitempty"`
}

// ApiResultResponseListPersonDTO defines model for ApiResultResponseListPersonDTO.
type ApiResultResponseListPersonDTO struct {
	// ErrorCode Is the error code returned from api
	ErrorCode int32 `json:"errorCode"`

	// ErrorDomain In case of error not equal to 0, an error domain can be reported by api, indicating where the problem is occurred
	ErrorDomain *string `json:"errorDomain,omitempty"`

	// ErrorMessage In case of error not equal to 0, an error message can be reported by api, indicating what problem is occurred
	ErrorMessage *string `json:"errorMessage,omitempty"`

	// Payload Is the value returned by api
	Payload *[]PersonDTO `json:"payload,omitempty"`
}

// ApiResultResponseMapStringString defines model for ApiResultResponseMapStringString.
type ApiResultResponseMapStringString struct {
	// ErrorCode Is the error code returned from api
	ErrorCode int32 `json:"errorCode"`

	// ErrorDomain In case of error not equal to 0, an error domain can be reported by api, indicating where the problem is occurred
	ErrorDomain *string `json:"errorDomain,omitempty"`

	// ErrorMessage In case of error not equal to 0, an error message can be reported by api, indicating what problem is occurred
	ErrorMessage *string `json:"errorMessage,omitempty"`

	// Payload Is the value returned by api
	Payload *map[string]string `json:"payload,omitempty"`
}

// ApiResultResponsePersonDTO defines model for ApiResultResponsePersonDTO.
type ApiResultResponsePersonDTO struct {
	// ErrorCode Is the error code returned from api
	ErrorCode int32 `json:"errorCode"`

	// ErrorDomain In case of error not equal to 0, an error domain can be reported by api, indicating where the problem is occurred
	ErrorDomain *string `json:"errorDomain,omitempty"`

	// ErrorMessage In case of error not equal to 0, an error message can be reported by api, indicating what problem is occurred
	ErrorMessage *string `json:"errorMessage,omitempty"`

	// Payload Is the value returned by api
	Payload *PersonDTO `json:"payload,omitempty"`
}

// ApiResultResponseString defines model for ApiResultResponseString.
type ApiResultResponseString struct {
	// ErrorCode Is the error code returned from api
	ErrorCode int32 `json:"errorCode"`

	// ErrorDomain In case of error not equal to 0, an error domain can be reported by api, indicating where the problem is occurred
	ErrorDomain *string `json:"errorDomain,omitempty"`

	// ErrorMessage In case of error not equal to 0, an error message can be reported by api, indicating what problem is occurred
	ErrorMessage *string `json:"errorMessage,omitempty"`

	// Payload Is the value returned by api
	Payload *string `json:"payload,omitempty"`
}

// AuthenticationTokenDTO The authentication token
type AuthenticationTokenDTO struct {
	ApplicationManaged *bool               `json:"applicationManaged,omitempty"`
	Email              *string             `json:"email,omitempty"`
	Expiration         *openapi_types.Date `json:"expiration,omitempty"`
	Id                 *string             `json:"id,omitempty"`
	Name               *string             `json:"name,omitempty"`
	Token              *string             `json:"token,omitempty"`
}

// AuthorizationDTO The authorization of the user on the resources returned in the payload
type AuthorizationDTO struct {
	// AuthorizationType Is the type of the authorizations [User, Group, Application]
	AuthorizationType *AuthorizationDTOAuthorizationType `json:"authorizationType,omitempty"`

	// Id Is unique id of the authorizations
	Id *string `json:"id,omitempty"`

	// Owner Is the subject owner of the authorizations
	Owner *string `json:"owner,omitempty"`

	// OwnerType Is the type of the owner [User, Group, Application]
	OwnerType *AuthorizationDTOOwnerType `json:"ownerType,omitempty"`

	// Resource The resource eof the authorizations
	Resource *string `json:"resource,omitempty"`
}

// AuthorizationDTOAuthorizationType Is the type of the authorizations [User, Group, Application]
type AuthorizationDTOAuthorizationType string

// AuthorizationDTOOwnerType Is the type of the owner [User, Group, Application]
type AuthorizationDTOOwnerType string

// ComponentDTO Define the single component
type ComponentDTO struct {
	// Id The unique identifier of the component
	Id *string `json:"id,omitempty"`

	// Name The name of the component
	Name *string `json:"name,omitempty"`
}

// GroupDTO The group of the user
type GroupDTO struct {
	CommonName *string `json:"commonName,omitempty"`
	Uid        *string `json:"uid,omitempty"`
}

// NewAuthenticationTokenDTO New authentication token for logbook
type NewAuthenticationTokenDTO struct {
	Expiration *openapi_types.Date `json:"expiration,omitempty"`
	Name       *string             `json:"name,omitempty"`
}

// NewComponentDTO Define details for create a new component
type NewComponentDTO struct {
	// BuildCommandTemplateIds The list of unique identifier of the command templates that this component uses to build.
	BuildCommandTemplateIds []string `json:"buildCommandTemplateIds"`

	// DependOnComponentIds The list of unique identifier of the components that this component depends on.
	DependOnComponentIds *[]string `json:"dependOnComponentIds,omitempty"`

	// Name The name of the component
	Name string `json:"name"`

	// Url The URL of the component [src, artifact, etc.]
	Url string `json:"url"`

	// Version The version of the component
	Version string `json:"version"`
}

// PersonDTO Is the value returned by api
type PersonDTO struct {
	CommonName *string `json:"commonName,omitempty"`
	Gecos      *string `json:"gecos,omitempty"`
	Mail       *string `json:"mail,omitempty"`
	Surname    *string `json:"surname,omitempty"`
	Uid        *string `json:"uid,omitempty"`
}

// FindGroupsParams defines parameters for FindGroups.
type FindGroupsParams struct {
	// Search is the prefix used to filter the groups
	Search *string `form:"search,omitempty" json:"search,omitempty"`
}

// FindPeopleParams defines parameters for FindPeople.
type FindPeopleParams struct {
	// Search is the prefix used to filter the people
	Search *string `form:"search,omitempty" json:"search,omitempty"`
}

// CreateNewAuthenticationTokenJSONRequestBody defines body for CreateNewAuthenticationToken for application/json ContentType.
type CreateNewAuthenticationTokenJSONRequestBody = NewAuthenticationTokenDTO

// CreateJSONRequestBody defines body for Create for application/json ContentType.
type CreateJSONRequestBody = NewComponentDTO

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// GetApplicationAuthenticationToken request
	GetApplicationAuthenticationToken(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateNewAuthenticationTokenWithBody request with any body
	CreateNewAuthenticationTokenWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateNewAuthenticationToken(ctx context.Context, body CreateNewAuthenticationTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteAuthenticationToken request
	DeleteAuthenticationToken(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindGroups request
	FindGroups(ctx context.Context, params *FindGroupsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Me request
	Me(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindAllRoot request
	FindAllRoot(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveAsRootUser request
	RemoveAsRootUser(ctx context.Context, email string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetRootUser request
	SetRootUser(ctx context.Context, email string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindPeople request
	FindPeople(ctx context.Context, params *FindPeopleParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListAllComponent request
	ListAllComponent(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateWithBody request with any body
	CreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	Create(ctx context.Context, body CreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Echo request
	Echo(ctx context.Context, value string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMockUser request
	GetMockUser(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) GetApplicationAuthenticationToken(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetApplicationAuthenticationTokenRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateNewAuthenticationTokenWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateNewAuthenticationTokenRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateNewAuthenticationToken(ctx context.Context, body CreateNewAuthenticationTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateNewAuthenticationTokenRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteAuthenticationToken(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteAuthenticationTokenRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindGroups(ctx context.Context, params *FindGroupsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindGroupsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Me(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMeRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindAllRoot(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindAllRootRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveAsRootUser(ctx context.Context, email string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveAsRootUserRequest(c.Server, email)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetRootUser(ctx context.Context, email string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetRootUserRequest(c.Server, email)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindPeople(ctx context.Context, params *FindPeopleParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindPeopleRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListAllComponent(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListAllComponentRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Create(ctx context.Context, body CreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Echo(ctx context.Context, value string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEchoRequest(c.Server, value)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMockUser(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMockUserRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewGetApplicationAuthenticationTokenRequest generates requests for GetApplicationAuthenticationToken
func NewGetApplicationAuthenticationTokenRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/auth/application-token")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateNewAuthenticationTokenRequest calls the generic CreateNewAuthenticationToken builder with application/json body
func NewCreateNewAuthenticationTokenRequest(server string, body CreateNewAuthenticationTokenJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateNewAuthenticationTokenRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateNewAuthenticationTokenRequestWithBody generates requests for CreateNewAuthenticationToken with any type of body
func NewCreateNewAuthenticationTokenRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/auth/application-token")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteAuthenticationTokenRequest generates requests for DeleteAuthenticationToken
func NewDeleteAuthenticationTokenRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/auth/application-token/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindGroupsRequest generates requests for FindGroups
func NewFindGroupsRequest(server string, params *FindGroupsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/auth/groups")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Search != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "search", runtime.ParamLocationQuery, *params.Search); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewMeRequest generates requests for Me
func NewMeRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/auth/me")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindAllRootRequest generates requests for FindAllRoot
func NewFindAllRootRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/auth/root")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRemoveAsRootUserRequest generates requests for RemoveAsRootUser
func NewRemoveAsRootUserRequest(server string, email string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "email", runtime.ParamLocationPath, email)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/auth/root/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetRootUserRequest generates requests for SetRootUser
func NewSetRootUserRequest(server string, email string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "email", runtime.ParamLocationPath, email)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/auth/root/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindPeopleRequest generates requests for FindPeople
func NewFindPeopleRequest(server string, params *FindPeopleParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/auth/users")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Search != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "search", runtime.ParamLocationQuery, *params.Search); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListAllComponentRequest generates requests for ListAllComponent
func NewListAllComponentRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/component")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateRequest calls the generic Create builder with application/json body
func NewCreateRequest(server string, body CreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateRequestWithBody generates requests for Create with any type of body
func NewCreateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/component")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewEchoRequest generates requests for Echo
func NewEchoRequest(server string, value string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "value", runtime.ParamLocationPath, value)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/echo/test/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetMockUserRequest generates requests for GetMockUser
func NewGetMockUserRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/mock/users-auth")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// GetApplicationAuthenticationTokenWithResponse request
	GetApplicationAuthenticationTokenWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetApplicationAuthenticationTokenResponse, error)

	// CreateNewAuthenticationTokenWithBodyWithResponse request with any body
	CreateNewAuthenticationTokenWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateNewAuthenticationTokenResponse, error)

	CreateNewAuthenticationTokenWithResponse(ctx context.Context, body CreateNewAuthenticationTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateNewAuthenticationTokenResponse, error)

	// DeleteAuthenticationTokenWithResponse request
	DeleteAuthenticationTokenWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteAuthenticationTokenResponse, error)

	// FindGroupsWithResponse request
	FindGroupsWithResponse(ctx context.Context, params *FindGroupsParams, reqEditors ...RequestEditorFn) (*FindGroupsResponse, error)

	// MeWithResponse request
	MeWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*MeResponse, error)

	// FindAllRootWithResponse request
	FindAllRootWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*FindAllRootResponse, error)

	// RemoveAsRootUserWithResponse request
	RemoveAsRootUserWithResponse(ctx context.Context, email string, reqEditors ...RequestEditorFn) (*RemoveAsRootUserResponse, error)

	// SetRootUserWithResponse request
	SetRootUserWithResponse(ctx context.Context, email string, reqEditors ...RequestEditorFn) (*SetRootUserResponse, error)

	// FindPeopleWithResponse request
	FindPeopleWithResponse(ctx context.Context, params *FindPeopleParams, reqEditors ...RequestEditorFn) (*FindPeopleResponse, error)

	// ListAllComponentWithResponse request
	ListAllComponentWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListAllComponentResponse, error)

	// CreateWithBodyWithResponse request with any body
	CreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateResponse, error)

	CreateWithResponse(ctx context.Context, body CreateJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateResponse, error)

	// EchoWithResponse request
	EchoWithResponse(ctx context.Context, value string, reqEditors ...RequestEditorFn) (*EchoResponse, error)

	// GetMockUserWithResponse request
	GetMockUserWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetMockUserResponse, error)
}

type GetApplicationAuthenticationTokenResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ApiResultResponseListAuthenticationTokenDTO
}

// Status returns HTTPResponse.Status
func (r GetApplicationAuthenticationTokenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetApplicationAuthenticationTokenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateNewAuthenticationTokenResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *ApiResultResponseAuthenticationTokenDTO
}

// Status returns HTTPResponse.Status
func (r CreateNewAuthenticationTokenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateNewAuthenticationTokenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteAuthenticationTokenResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ApiResultResponseBoolean
}

// Status returns HTTPResponse.Status
func (r DeleteAuthenticationTokenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteAuthenticationTokenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindGroupsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ApiResultResponseListGroupDTO
}

// Status returns HTTPResponse.Status
func (r FindGroupsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindGroupsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ApiResultResponsePersonDTO
}

// Status returns HTTPResponse.Status
func (r MeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindAllRootResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ApiResultResponseListAuthorizationDTO
}

// Status returns HTTPResponse.Status
func (r FindAllRootResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindAllRootResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveAsRootUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ApiResultResponseBoolean
}

// Status returns HTTPResponse.Status
func (r RemoveAsRootUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveAsRootUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetRootUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *ApiResultResponseBoolean
}

// Status returns HTTPResponse.Status
func (r SetRootUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetRootUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindPeopleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ApiResultResponseListPersonDTO
}

// Status returns HTTPResponse.Status
func (r FindPeopleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindPeopleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListAllComponentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ApiResultResponseListComponentDTO
}

// Status returns HTTPResponse.Status
func (r ListAllComponentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListAllComponentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *ApiResultResponseString
}

// Status returns HTTPResponse.Status
func (r CreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EchoResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ApiResultResponseString
}

// Status returns HTTPResponse.Status
func (r EchoResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EchoResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMockUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ApiResultResponseMapStringString
}

// Status returns HTTPResponse.Status
func (r GetMockUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMockUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetApplicationAuthenticationTokenWithResponse request returning *GetApplicationAuthenticationTokenResponse
func (c *ClientWithResponses) GetApplicationAuthenticationTokenWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetApplicationAuthenticationTokenResponse, error) {
	rsp, err := c.GetApplicationAuthenticationToken(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetApplicationAuthenticationTokenResponse(rsp)
}

// CreateNewAuthenticationTokenWithBodyWithResponse request with arbitrary body returning *CreateNewAuthenticationTokenResponse
func (c *ClientWithResponses) CreateNewAuthenticationTokenWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateNewAuthenticationTokenResponse, error) {
	rsp, err := c.CreateNewAuthenticationTokenWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateNewAuthenticationTokenResponse(rsp)
}

func (c *ClientWithResponses) CreateNewAuthenticationTokenWithResponse(ctx context.Context, body CreateNewAuthenticationTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateNewAuthenticationTokenResponse, error) {
	rsp, err := c.CreateNewAuthenticationToken(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateNewAuthenticationTokenResponse(rsp)
}

// DeleteAuthenticationTokenWithResponse request returning *DeleteAuthenticationTokenResponse
func (c *ClientWithResponses) DeleteAuthenticationTokenWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteAuthenticationTokenResponse, error) {
	rsp, err := c.DeleteAuthenticationToken(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteAuthenticationTokenResponse(rsp)
}

// FindGroupsWithResponse request returning *FindGroupsResponse
func (c *ClientWithResponses) FindGroupsWithResponse(ctx context.Context, params *FindGroupsParams, reqEditors ...RequestEditorFn) (*FindGroupsResponse, error) {
	rsp, err := c.FindGroups(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindGroupsResponse(rsp)
}

// MeWithResponse request returning *MeResponse
func (c *ClientWithResponses) MeWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*MeResponse, error) {
	rsp, err := c.Me(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMeResponse(rsp)
}

// FindAllRootWithResponse request returning *FindAllRootResponse
func (c *ClientWithResponses) FindAllRootWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*FindAllRootResponse, error) {
	rsp, err := c.FindAllRoot(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindAllRootResponse(rsp)
}

// RemoveAsRootUserWithResponse request returning *RemoveAsRootUserResponse
func (c *ClientWithResponses) RemoveAsRootUserWithResponse(ctx context.Context, email string, reqEditors ...RequestEditorFn) (*RemoveAsRootUserResponse, error) {
	rsp, err := c.RemoveAsRootUser(ctx, email, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveAsRootUserResponse(rsp)
}

// SetRootUserWithResponse request returning *SetRootUserResponse
func (c *ClientWithResponses) SetRootUserWithResponse(ctx context.Context, email string, reqEditors ...RequestEditorFn) (*SetRootUserResponse, error) {
	rsp, err := c.SetRootUser(ctx, email, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetRootUserResponse(rsp)
}

// FindPeopleWithResponse request returning *FindPeopleResponse
func (c *ClientWithResponses) FindPeopleWithResponse(ctx context.Context, params *FindPeopleParams, reqEditors ...RequestEditorFn) (*FindPeopleResponse, error) {
	rsp, err := c.FindPeople(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindPeopleResponse(rsp)
}

// ListAllComponentWithResponse request returning *ListAllComponentResponse
func (c *ClientWithResponses) ListAllComponentWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListAllComponentResponse, error) {
	rsp, err := c.ListAllComponent(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListAllComponentResponse(rsp)
}

// CreateWithBodyWithResponse request with arbitrary body returning *CreateResponse
func (c *ClientWithResponses) CreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateResponse, error) {
	rsp, err := c.CreateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateResponse(rsp)
}

func (c *ClientWithResponses) CreateWithResponse(ctx context.Context, body CreateJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateResponse, error) {
	rsp, err := c.Create(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateResponse(rsp)
}

// EchoWithResponse request returning *EchoResponse
func (c *ClientWithResponses) EchoWithResponse(ctx context.Context, value string, reqEditors ...RequestEditorFn) (*EchoResponse, error) {
	rsp, err := c.Echo(ctx, value, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEchoResponse(rsp)
}

// GetMockUserWithResponse request returning *GetMockUserResponse
func (c *ClientWithResponses) GetMockUserWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetMockUserResponse, error) {
	rsp, err := c.GetMockUser(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMockUserResponse(rsp)
}

// ParseGetApplicationAuthenticationTokenResponse parses an HTTP response from a GetApplicationAuthenticationTokenWithResponse call
func ParseGetApplicationAuthenticationTokenResponse(rsp *http.Response) (*GetApplicationAuthenticationTokenResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetApplicationAuthenticationTokenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ApiResultResponseListAuthenticationTokenDTO
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateNewAuthenticationTokenResponse parses an HTTP response from a CreateNewAuthenticationTokenWithResponse call
func ParseCreateNewAuthenticationTokenResponse(rsp *http.Response) (*CreateNewAuthenticationTokenResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateNewAuthenticationTokenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest ApiResultResponseAuthenticationTokenDTO
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseDeleteAuthenticationTokenResponse parses an HTTP response from a DeleteAuthenticationTokenWithResponse call
func ParseDeleteAuthenticationTokenResponse(rsp *http.Response) (*DeleteAuthenticationTokenResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteAuthenticationTokenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ApiResultResponseBoolean
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseFindGroupsResponse parses an HTTP response from a FindGroupsWithResponse call
func ParseFindGroupsResponse(rsp *http.Response) (*FindGroupsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindGroupsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ApiResultResponseListGroupDTO
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseMeResponse parses an HTTP response from a MeWithResponse call
func ParseMeResponse(rsp *http.Response) (*MeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ApiResultResponsePersonDTO
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseFindAllRootResponse parses an HTTP response from a FindAllRootWithResponse call
func ParseFindAllRootResponse(rsp *http.Response) (*FindAllRootResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindAllRootResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ApiResultResponseListAuthorizationDTO
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseRemoveAsRootUserResponse parses an HTTP response from a RemoveAsRootUserWithResponse call
func ParseRemoveAsRootUserResponse(rsp *http.Response) (*RemoveAsRootUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemoveAsRootUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ApiResultResponseBoolean
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseSetRootUserResponse parses an HTTP response from a SetRootUserWithResponse call
func ParseSetRootUserResponse(rsp *http.Response) (*SetRootUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetRootUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest ApiResultResponseBoolean
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseFindPeopleResponse parses an HTTP response from a FindPeopleWithResponse call
func ParseFindPeopleResponse(rsp *http.Response) (*FindPeopleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindPeopleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ApiResultResponseListPersonDTO
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListAllComponentResponse parses an HTTP response from a ListAllComponentWithResponse call
func ParseListAllComponentResponse(rsp *http.Response) (*ListAllComponentResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListAllComponentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ApiResultResponseListComponentDTO
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateResponse parses an HTTP response from a CreateWithResponse call
func ParseCreateResponse(rsp *http.Response) (*CreateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest ApiResultResponseString
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseEchoResponse parses an HTTP response from a EchoWithResponse call
func ParseEchoResponse(rsp *http.Response) (*EchoResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EchoResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ApiResultResponseString
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetMockUserResponse parses an HTTP response from a GetMockUserWithResponse call
func ParseGetMockUserResponse(rsp *http.Response) (*GetMockUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMockUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ApiResultResponseMapStringString
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ServerInterface represents all server handlers.
type ServerInterface interface {

	// (GET /v1/auth/application-token)
	GetApplicationAuthenticationToken(ctx echo.Context) error

	// (POST /v1/auth/application-token)
	CreateNewAuthenticationToken(ctx echo.Context) error

	// (DELETE /v1/auth/application-token/{id})
	DeleteAuthenticationToken(ctx echo.Context, id string) error

	// (GET /v1/auth/groups)
	FindGroups(ctx echo.Context, params FindGroupsParams) error

	// (GET /v1/auth/me)
	Me(ctx echo.Context) error

	// (GET /v1/auth/root)
	FindAllRoot(ctx echo.Context) error

	// (DELETE /v1/auth/root/{email})
	RemoveAsRootUser(ctx echo.Context, email string) error

	// (POST /v1/auth/root/{email})
	SetRootUser(ctx echo.Context, email string) error

	// (GET /v1/auth/users)
	FindPeople(ctx echo.Context, params FindPeopleParams) error
	// Download a content from a file entry
	// (GET /v1/component)
	ListAllComponent(ctx echo.Context) error
	// Download a content from a file entry
	// (POST /v1/component)
	Create(ctx echo.Context) error
	// Example api that realize an ECHO
	// (GET /v1/echo/test/{value})
	Echo(ctx echo.Context, value string) error

	// (GET /v1/mock/users-auth)
	GetMockUser(ctx echo.Context) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// GetApplicationAuthenticationToken converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationAuthenticationToken(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetApplicationAuthenticationToken(ctx)
	return err
}

// CreateNewAuthenticationToken converts echo context to params.
func (w *ServerInterfaceWrapper) CreateNewAuthenticationToken(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.CreateNewAuthenticationToken(ctx)
	return err
}

// DeleteAuthenticationToken converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteAuthenticationToken(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteAuthenticationToken(ctx, id)
	return err
}

// FindGroups converts echo context to params.
func (w *ServerInterfaceWrapper) FindGroups(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params FindGroupsParams
	// ------------- Optional query parameter "search" -------------

	err = runtime.BindQueryParameter("form", true, false, "search", ctx.QueryParams(), &params.Search)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter search: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.FindGroups(ctx, params)
	return err
}

// Me converts echo context to params.
func (w *ServerInterfaceWrapper) Me(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.Me(ctx)
	return err
}

// FindAllRoot converts echo context to params.
func (w *ServerInterfaceWrapper) FindAllRoot(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.FindAllRoot(ctx)
	return err
}

// RemoveAsRootUser converts echo context to params.
func (w *ServerInterfaceWrapper) RemoveAsRootUser(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "email" -------------
	var email string

	err = runtime.BindStyledParameterWithOptions("simple", "email", ctx.Param("email"), &email, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter email: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.RemoveAsRootUser(ctx, email)
	return err
}

// SetRootUser converts echo context to params.
func (w *ServerInterfaceWrapper) SetRootUser(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "email" -------------
	var email string

	err = runtime.BindStyledParameterWithOptions("simple", "email", ctx.Param("email"), &email, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter email: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.SetRootUser(ctx, email)
	return err
}

// FindPeople converts echo context to params.
func (w *ServerInterfaceWrapper) FindPeople(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params FindPeopleParams
	// ------------- Optional query parameter "search" -------------

	err = runtime.BindQueryParameter("form", true, false, "search", ctx.QueryParams(), &params.Search)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter search: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.FindPeople(ctx, params)
	return err
}

// ListAllComponent converts echo context to params.
func (w *ServerInterfaceWrapper) ListAllComponent(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ListAllComponent(ctx)
	return err
}

// Create converts echo context to params.
func (w *ServerInterfaceWrapper) Create(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.Create(ctx)
	return err
}

// Echo converts echo context to params.
func (w *ServerInterfaceWrapper) Echo(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "value" -------------
	var value string

	err = runtime.BindStyledParameterWithOptions("simple", "value", ctx.Param("value"), &value, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter value: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.Echo(ctx, value)
	return err
}

// GetMockUser converts echo context to params.
func (w *ServerInterfaceWrapper) GetMockUser(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetMockUser(ctx)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {
	RegisterHandlersWithBaseURL(router, si, "")
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/v1/auth/application-token", wrapper.GetApplicationAuthenticationToken)
	router.POST(baseURL+"/v1/auth/application-token", wrapper.CreateNewAuthenticationToken)
	router.DELETE(baseURL+"/v1/auth/application-token/:id", wrapper.DeleteAuthenticationToken)
	router.GET(baseURL+"/v1/auth/groups", wrapper.FindGroups)
	router.GET(baseURL+"/v1/auth/me", wrapper.Me)
	router.GET(baseURL+"/v1/auth/root", wrapper.FindAllRoot)
	router.DELETE(baseURL+"/v1/auth/root/:email", wrapper.RemoveAsRootUser)
	router.POST(baseURL+"/v1/auth/root/:email", wrapper.SetRootUser)
	router.GET(baseURL+"/v1/auth/users", wrapper.FindPeople)
	router.GET(baseURL+"/v1/component", wrapper.ListAllComponent)
	router.POST(baseURL+"/v1/component", wrapper.Create)
	router.GET(baseURL+"/v1/echo/test/:value", wrapper.Echo)
	router.GET(baseURL+"/v1/mock/users-auth", wrapper.GetMockUser)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"H4sIAAAAAAAC/+xaT3PbuBX/Khi0py5l2ruXrU6VZTf1bJxkLO9kphkfIOBJwgYEGACUrXj03TsAKJEU",
	"QUW2ZKfZ1SWxDfD9/b0fHh75iKnKciVBWoP7j9jQGWTE/zjI+Q2YQtgbMLmSBgaFnYG0nBLLlbxVn0Fe",
	"3L53W3OtctCWg38QtFZ6qBi4XxgYqnnunsB9fGWQnQHyOxBVDJAGW2gJDE20yhDJOU7wROmMWNzHXNpf",
	"fsYJtoscwq8wBY2XSdBxoTLCZUSLRJQYQGpSapLKIvhSEIGsQqcJIrJcYF4CokSisbMlV9oCQ+OFsyRB",
	"XDLvrZyi+xlo8MbnWo0FZIgbpCgttAZWmWis5nK6tvAajCFT2MfELIjYzUZidzUvJwuhCHOW/V3DBPfx",
	"39IKCmmJg7Qj58tlgjV8KbiT3v9US/ndWpca/wHUOl0tJJ0rJYDII3R+dOhEUzQnoqhlJ2irBI3L5O+J",
	"obfc2CMjHWGFuYXMPJfH1nYQrcniUJhUmn/1io5oPKKxA40NjLwADocrtUcMHjEYwWADHy+AvzdaFfkR",
	"e0fsRbC3xsYL4O4DaHM8eI/AiwKvAseBkXdN8pF3Ifx7xN6Pjj3CGHdmEfGhkcfn3HgrBc95eoW6/QB6",
	"pMW/xLyuRnD74eXIY3/dCd1K0NMQ1DmLa5pwOwNEGnuRdZtxsoE0kuei3HFNJJmC92dziJhgyAgXtaVa",
	"lh5yrknQ+1gBjxELsahxFpUiSQbRhWB2e2XZEZ3NqVA8LutdDj4uWYUBjVyUZi5lRhWagqmSx8PKKuWt",
	"KNZF3nqzOkDhbF7pbDxl0KffDegE+bY9QYMqMXc4wSCLzMHjBrz6j5r78A5YxmUNKZtxbtlQSP6lAMRZ",
	"3IhYxtS9BN3pkCl8+JHf9UShO0cqCN8pQG4PTrDfhBPsSyQaoFWW4yBZrSLY0aUYHjenQ001FzDhMhCi",
	"4XIqAK2PmhbAYtl0Zq7T6Qp9wqsM1EV1FltbnlvZQUTM2foooi146lbrxdZykaosU/JdFw8UUeKIGfIO",
	"7nelyXdwH6VJNFEaCTUdK/W5ZegTCa+D2Tos3wkyDCzhwngrqQZiAREk4X4LgMYFF2yosoxIdgtZLoiF",
	"K2biyRLcWJerbehygpAtJbmKJRbZGTeVDS7Nxp3FXvdJ/fb4eirb50n9PprgoO8qGGZ1Af7+kINk7+U6",
	"F3sFqmweo+YGTQYpeYDw7K7oOUHZmzMSXGgRl/D7zduWAPTJaJogoi2fEGoTBJae3MXEzkGbshjbosvF",
	"3Tit3od1FUwZieBNpTzWrDVug09qEZ/EjFOgykRXOns2U2i5L9E6MUALze1i5O5FwdZzIBo0cgTszy3n",
	"7AwI84QfdOKH3lwVdNbjLO8RSsGYVW+6wmHOf4MFXjodXE5UCIK0hFpPwMEvPOYGppL/yxB6YiyRE6XZ",
	"CbCi0jT4cIVGRe76/TJjfTyzNjf9NKVKTkQBksKJERsSUsZNLsgivby8+Di4cP/99BHGP9V6DtOeNAyV",
	"BnTucINGC2MhQ06/I2mX6wGlIEATqzS64HPuYUksGr0dDNE7EsYgjV1vyVj5n1xNWm4FdCmpAbGPfXuV",
	"g3RQ6uNfTk5PzhykiJ35DKXzs9SdeWmt9e+tu+wp+BA7+PmVK4b7+A3YmueRwxX7dspfab2On09PVzlz",
	"tda8Z6R/mFCt4Tr9zdd4T/gmwSOmmZT3vwXwkqlxZd1o43rOQK2EAI3v3I1OmYj3Q3/CxrsKHEgDjD1X",
	"bHEwn7tbmGWTp0py3gj+2csFf/fAh7CxXaO/TLYgM33kbBlYVICFdo4u/N/jCcqJJhlY0M6EDiIuz1Vo",
	"3osit2dPaK6WKpLhDG+mJKmFd5NI716zVs7XnwHtURj11Pg+3nQyxb+5ZG/Clm8EnptyFAQT/uD6Nub6",
	"tgkXFgJfTldifMi/FOBpsIy5AaKpy8H/SZwb72IPFuxwQkcDfQ2vyrn1ieeBnNNK2a04Gghx4/Z8j7Ol",
	"+d3IIV1OH337spXNbiBTcxgY5345z9iopQgNha7oz81EXUf0COyrx+rsu8Rqj1O1MD4iWyruA6hcwN7M",
	"na/E/CjMfVh2q+6YXbH2LCPEsHYZfV2Hm58ldfpsiiwjeuH6K3UvhSIMEVRaVb5tcnkHBNKGS0oZpLUd",
	"T+mwX66Xbrv7HTvo0QrmW2v70KEvsQl0plILxqaPfvaw7MToJZ2pHZvnMMXwY6d7LkR4x1a9OHE5R2vh",
	"8R7ai9hKyAfRnBNrQTsBn0jv66D339PeP+/+EZkFvSoFdSOiVYeXDyTLBSCS8+C2BiL4V0BEosvhf97X",
	"gOASiIZrDKD5WQWDTNHP4TzokXJS03Xxv1b0c3muvl5ENj/0+TYtO496zqMN2PsplZ7H8fsGpPMWGAp7",
	"UJjpVXOifprSsen/evrrKXaYKLVtyhmBnnMKyBUWl9NyiFdCO5KH5d3yfwEAAP//iMvbeBM2AAA=",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
